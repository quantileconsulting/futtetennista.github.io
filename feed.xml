<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <title>Futtetennismo</title>
    <link href="https://futtetennismo.me/feed.xml" rel="self" />
    <link href="https://futtetennismo.me" />
    <id>https://futtetennismo.me/feed.xml</id>
    <author>
        <name>futtetennista</name>
        <email>futtetennista@gmail.com</email>
    </author>
    <updated>2018-07-13T00:00:00Z</updated>
    <entry>
    <title>Deploy Yesod Applications to Heroku with Docker</title>
    <link href="https://futtetennismo.me/posts/haskell/2018-07-13-yesod-docker-on-heroku.html" />
    <id>https://futtetennismo.me/posts/haskell/2018-07-13-yesod-docker-on-heroku.html</id>
    <published>2018-07-13T00:00:00Z</published>
    <updated>2018-07-13T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>This post is based on a previous post but we will be pushing a docker image to heroku instead. If you follow this guide step by step, you should have a demo application running on heroku(in a docker container)!</p>
<!--more-->
<p>If you have not installed the heroku cli tools on your local computer, please do so now. I recommend that you follow the heroku documentation to install the cli tools and add your personal ssh key. You will also need to install the stack tool for building haskell applications on your local computer. Then come back to this guide.</p>
<h3 id="create-a-new-project-and-set-up-git">Create a new project and set up git</h3>
<ol style="list-style-type: decimal">
<li><p><code>stack new myproj yesod-postgres</code> to have a new project created by <code>stack</code> using the <code>yesod-postgres</code> template. I assume you want to call your project <code>myproj</code>, for instance.</p></li>
<li><p>Go to your project folder and do</p>
<pre class="shell"><code>git init
git add .
git commit -m &quot;initial commit&quot;</code></pre></li>
</ol>
<h3 id="create-a-project-on-heroku">Create a project on heroku</h3>
<ol style="list-style-type: decimal">
<li>Create a project on heroku server: <code>heroku apps:create appname -b    https://github.com/mfine/heroku-buildpack-stack.git</code>. Note we are using a special buildpack for deloying haskell application to heroku.</li>
<li><p>Add the free “Hobby Dev Plan” posgresql add-on: <code>heroku addon:add    heroku-postgresql:hobby-dev</code>. More detalis <a href="https://devcenter.heroku.com/articles/heroku-postgresql#promote-your-database-and-begin-using-it">here</a>.</p></li>
<li><p>Now you need to get the connection info for the pg database by <code>heroku    pg:credentials:url DATABASE</code> and the output will be sth. in the line of</p>
<pre><code>Connection information for default credential.
Connection info string:
&quot;dbname=DBNAME host=HOSTNAME
port=5432 user=USERNAME
password=PASSWORD
sslmode=require&quot;
Connection URL:
   postgres://USERNAME:PASSWORD@HOSTNAME:5432/DBNAME</code></pre></li>
<li><p>Now go to the heroku web console, click on the project that you just created, then click on <code>Setting</code> and then <code>Config vars</code> and add these env vars to you project: <code>YESOD_PGHOST</code>,<code>YESOD_PGPORT</code>, <code>YESOD_PGUSER</code>, <code>YESOD_PGPASS</code> and <code>YESOD_PGDATABASE</code>, the values are those you got from the last step.<br />
N.B. the name of these variables may change from one build plan to another, you would need to look at <code>config/settings.yaml</code> file to see what the names need to be.</p></li>
<li><p>Now go visit <code>config/settings.yaml</code> and find the line <code>port    &quot;_env:PORT:3000&quot;</code> and make sure you have <code>PORT</code> and nothing else after the <code>_env:</code>. This is very important because <code>PORT</code> is an env var set by heroku and your app is only able to bind to this port. If you have anything else there your app will fail to start.</p></li>
<li><p>Now create the <code>Dockerfile</code> and fill it with the following content ``` FROM heroku/heroku:16</p></li>
</ol>
<p>ENV LANG C.UTF-8</p>
<h1 id="install-required-packages.">Install required packages.</h1>
<p>RUN apt-get update RUN apt-get upgrade -y –assume-yes # Install packages for stack and ghc. RUN apt-get install -y –assume-yes xz-utils gcc libgmp-dev zlib1g-dev # Install packages needed for libraries used by our app. RUN apt-get install -y –assume-yes libpq-dev # Install convenience utilities, like tree, ping, and vim. RUN apt-get install -y –assume-yes tree iputils-ping vim-nox</p>
<h1 id="remove-apt-caches-to-reduce-the-size-of-our-container.">Remove apt caches to reduce the size of our container.</h1>
<p>RUN rm -rf /var/lib/apt/lists/*</p>
<h1 id="install-stack-to-optstackbin.">Install stack to /opt/stack/bin.</h1>
<p>RUN mkdir -p /opt/stack/bin RUN curl -L https://www.stackage.org/stack/linux-x86_64 | tar xz –wildcards –strip-components=1 -C /opt/stack/bin ’*/stack’</p>
<h1 id="create-optyesod-pg-dockerbin-and-optyesod-pg-dockersrc.-set">Create /opt/yesod-pg-docker/bin and /opt/yesod-pg-docker/src. Set</h1>
<h1 id="optyesod-pg-dockersrc-as-the-working-directory.">/opt/yesod-pg-docker/src as the working directory.</h1>
<p>RUN mkdir -p /opt/yesod-pg-docker/src RUN mkdir -p /opt/yesod-pg-docker/bin WORKDIR /opt/yesod-pg-docker/src</p>
<h1 id="set-the-path-for-the-root-user-so-they-can-use-stack.">Set the PATH for the root user so they can use stack.</h1>
<p>ENV PATH “$PATH:/opt/stack/bin:/opt/yesod-pg-docker/bin”</p>
<h1 id="install-ghc-using-stack-based-on-your-apps-stack.yaml-file.">Install GHC using stack, based on your app’s stack.yaml file.</h1>
<p>COPY ./stack.yaml /opt/yesod-pg-docker/src/stack.yaml RUN stack –no-terminal setup</p>
<h1 id="install-all-dependencies-in-apps-.cabal-file.">Install all dependencies in app’s .cabal file.</h1>
<p>COPY ./yesod-pg-docker.cabal /opt/yesod-pg-docker/src/yesod-pg-docker.cabal RUN stack –no-terminal test –only-dependencies</p>
<h1 id="build-application.">Build application.</h1>
<p>COPY . /opt/yesod-pg-docker RUN stack –no-terminal build</p>
<h1 id="install-application-binaries-to-optyesod-pg-dockerbin.">Install application binaries to /opt/yesod-pg-docker/bin.</h1>
<p>RUN stack –no-terminal –local-bin-path /opt/yesod-pg-docker/bin install</p>
<h1 id="remove-source-code.">Remove source code.</h1>
<h1 id="run-rm--rf-optyesod-pg-dockersrc">RUN rm -rf /opt/yesod-pg-docker/src</h1>
<h1 id="add-the-apiuser-and-setup-their-path.">Add the apiuser and setup their PATH.</h1>
<p>RUN useradd -ms /bin/bash apiuser RUN chown -R apiuser:apiuser /opt/yesod-pg-docker USER apiuser ENV PATH “$PATH:/opt/stack/bin:/opt/yesod-pg-docker/bin”</p>
<h1 id="set-the-working-directory-as-optyesod-pg-docker.">Set the working directory as /opt/yesod-pg-docker/.</h1>
<p>WORKDIR /opt/yesod-pg-docker</p>
<p>CMD /opt/yesod-pg-docker/bin/yesod-pg-docker-api ``<code>You may want to search and replace</code>yesod-pg-docker<code>by the name of your own   app in this</code>Dockefile`.</p>
<h3 id="deploy-it">Deploy it</h3>
<p>Now your project is ready to be deployed! Just do <code>heroku container:push web; heroku container:release web</code>, go grab a drink and come back in 20 minutes or so and you should see the demo application running on heroku! Congratulations!</p>]]></summary>
</entry>
<entry>
    <title>Deploy Yesod Applications to Heroku</title>
    <link href="https://futtetennismo.me/posts/haskell/2018-04-27-yesod-on-heroku.html" />
    <id>https://futtetennismo.me/posts/haskell/2018-04-27-yesod-on-heroku.html</id>
    <published>2018-04-27T00:00:00Z</published>
    <updated>2018-04-27T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>In this post I will show you a step by step guide on how to deploy an yesod application to heroku, with optional support of postgresql. If you follow this guide along, you should have a demo application running on heroku in the end.</p>
<!--more-->
<p>If you have not installed the heroku cli tools on your local computer, please do so now. I recommend that you follow the heroku documentation to install the cli tools and add your personal ssh key. You will also need to install the stack tool for building haskell applications on your local computer. Then come back to this guide.</p>
<h3 id="create-a-new-project-and-set-up-git">Create a new project and set up git</h3>
<ol style="list-style-type: decimal">
<li><p><code>stack new myproj yesod-postgres</code> to have a new project created by <code>stack</code> using the <code>yesod-postgres</code> template. I assume you want to call your project <code>myproj</code>, for instance.</p></li>
<li><p>Go to your project folder and do</p>
<pre class="shell"><code>git init
git add .
git commit -m &quot;initial commit&quot;</code></pre></li>
</ol>
<h3 id="create-a-project-on-heroku">Create a project on heroku</h3>
<ol style="list-style-type: decimal">
<li>Create a project on heroku server: <code>heroku apps:create appname -b    https://github.com/mfine/heroku-buildpack-stack.git</code>. Note we are using a special buildpack for deloying haskell application to heroku.</li>
<li><p>Add the free “Hobby Dev Plan” posgresql add-on: <code>heroku addon:add    heroku-postgresql:hobby-dev</code>. More detalis <a href="https://devcenter.heroku.com/articles/heroku-postgresql#promote-your-database-and-begin-using-it">here</a>.</p></li>
<li><p>Now you need to get the connection info for the pg database by <code>heroku    pg:credentials:url DATABASE</code> and the output will be sth. in the line of</p>
<pre><code>Connection information for default credential.
Connection info string:
&quot;dbname=DBNAME host=HOSTNAME
port=5432 user=USERNAME
password=PASSWORD
sslmode=require&quot;
Connection URL:
   postgres://USERNAME:PASSWORD@HOSTNAME:5432/DBNAME</code></pre></li>
<li><p>Now <code>cd</code> into the <code>config</code> directory in you project folder and open up the <code>settings.yml</code> file and find the sectin called <code>database</code> and replace the credentials with what you find in previous step.</p></li>
<li><p>Create <code>Procfile</code> in the root of your project directory and fill it with the following lines:</p>
<pre><code>web: myproj</code></pre>
<p>where myproj is the name you pick for your project(replace it with your real project name).</p></li>
</ol>
<h3 id="deploy-it">Deploy it</h3>
<p>Now your project is ready to be deployed! Just do <code>git push heroku</code>, go grab a drink and come back in 20 minutes or so and you should see the demo application running on heroku! Congratulations!</p>]]></summary>
</entry>
<entry>
    <title>Functional programming with graphs</title>
    <link href="https://futtetennismo.me/posts/algorithms-and-data-structures/2017-12-08-functional-graphs.html" />
    <id>https://futtetennismo.me/posts/algorithms-and-data-structures/2017-12-08-functional-graphs.html</id>
    <published>2017-12-08T00:00:00Z</published>
    <updated>2017-12-08T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Graphs are a fundamental data structure in computer science because <em>a lot</em> of problems can be modelled with them. Graph traversal, shortest path between two vertices, minimum spanning trees are all well-known algorithms and there is plenty of literature available. This applies to imperative languages but is it the same for functional languages? My first-hand experience is that this is not quite the case and answering a seemingly simple question like “how should I implement a graph algorithm in a functional programming language?” ends up being unexpectedly challenging.</p>
<!--more-->
<p>The following table gives a pretty good idea of how pervasive graphs are and why anyone should care to answer the question in the first place.</p>
<div class="figure">
<img src="/images/graph_applications.png" alt="Graph applications (image taken from a slide of the Algorithms part 2 MOOC on Coursera by Bob Sedgwick and Kevin Wayne)" />
<p class="caption">Graph applications (image taken from a slide of the Algorithms part 2 MOOC on <a href="https://www.coursera.org/learn/algorithms-part2/">Coursera</a> by Bob Sedgwick and Kevin Wayne)</p>
</div>
<p>Problems involving graphs are also not unusual during job interviews and this is actually where my curiosity about functional graph algorithms really took off: I was eager to learn how to approach those kind of problems functionally. When I started searching I honestly didn’t expect to have such a hard time finding material, and I do not even mean <em>good</em> material but any material at all! Maybe I didn’t look for it hard enough - if that’s the case please <a href="/about.html">let me know</a>! - but basically the only book on the subject of functional data structures out there is <a href="https://www.goodreads.com/book/show/594288.Purely_Functional_Data_Structures">Purely Functional Data Structures</a> by Chris Okasaki, released in 2008 (and it’s pretty advanced material) and the only book I am aware of that focused on functional algorithms is <a href="https://www.goodreads.com/book/show/8693802-pearls-of-functional-algorithm-design">Pearls of Functional Algorithm Design</a> by Richard Bird. Graphs and graph algorithms are no exception: there is a massive amount of literature available for imperative languages but it takes some <a href="http://duckduckgo.com/">DuckDuckGo</a>-fu to find literature on the topic for purely functional languages, and more often than not that literature comes in the form of academic papers. After a decent amount of digging my understanding is that lots of purely functional algorithms do exist but they are not as efficient as the imperative counterparts; this might be one of the reasons why they are basically shovelled under the carpet and not used in practice. So let’s try to answer a slightly different question first: How <em>can</em> I implement a graph algorithm in a functional programming language?</p>
<h2 id="imperative-style-algorithms-with-monads">Imperative-style algorithms with monads</h2>
<p>One option could be “translating” graph algorithms from the imperative world to the functional world but that turns out to be unsurprisingly unpleasant: one of the main reasons is that imperative graph algorithms rely heavily on state and side effects (sometimes for efficiency reasons). Let’s take Haskell as our functional programming language of choice, and try to translate the <a href="https://en.wikipedia.org/wiki/Depth-first_search">depth-first search (DFS)</a> algorithm as in <a href="https://www.goodreads.com/book/show/425208.The_Algorithm_Design_Manual">The Algorithm Design Manual</a> by Steven S. Skiena:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE KindSignatures #-}</span>
<span class="ot">{-# LANGUAGE BangPatterns #-}</span>
<span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE ScopedTypeVariables #-}</span>

<span class="kw">import </span><span class="dt">Data.Foldable</span> (foldlM)
<span class="kw">import qualified</span> <span class="dt">Data.Vector.Mutable</span> <span class="kw">as</span> <span class="dt">MV</span>
<span class="kw">import qualified</span> <span class="dt">Data.Sequence</span> <span class="kw">as</span> <span class="dt">Seq</span>
<span class="kw">import </span><span class="dt">Control.Monad.State.Strict</span> (<span class="dt">StateT</span>, evalStateT, gets, modify&#39;, get, lift)
<span class="kw">import </span><span class="dt">Control.Monad.ST</span> (<span class="dt">ST</span>, runST)
<span class="kw">import </span><span class="dt">Control.Applicative</span> (liftA2)
<span class="kw">import </span><span class="dt">Control.Monad.Primitive</span> (<span class="dt">PrimMonad</span>)

<span class="kw">data</span> <span class="dt">Graph</span> weight label <span class="fu">=</span> <span class="dt">Graph</span> [(label, [<span class="dt">EdgeNode</span> weight label])] <span class="dt">Directed</span> <span class="dt">Int</span> <span class="kw">deriving</span> <span class="dt">Eq</span>

<span class="kw">type</span> <span class="dt">EdgeNode</span> weight label <span class="fu">=</span> (label, weight)

<span class="kw">type</span> <span class="dt">VertexState</span> s <span class="fu">=</span> <span class="dt">MV.MVector</span> s <span class="dt">VState</span>

<span class="kw">data</span> <span class="dt">DFSState</span> s label weight <span class="fu">=</span>
  <span class="dt">DFSState</span> {<span class="ot"> dfsVertex ::</span> label
           ,<span class="ot"> dfsConnectedComponent ::</span> <span class="dt">ConnectedComponent</span> a weight
           ,<span class="ot"> dfsVertexState ::</span> <span class="dt">VertexState</span> s
           }

<span class="co">-- undiscovered, discovered or processed</span>
<span class="kw">data</span> <span class="dt">VState</span> <span class="fu">=</span> <span class="dt">U</span> <span class="fu">|</span> <span class="dt">D</span> <span class="fu">|</span> <span class="dt">P</span> <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>, <span class="dt">Ord</span>)

<span class="kw">type</span> <span class="dt">ConnectedComponent</span> weight label <span class="fu">=</span> <span class="dt">Tree</span> weight label

<span class="kw">data</span> <span class="dt">Tree</span> weight label <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Node</span> <span class="fu">!</span>label [(weight, <span class="dt">Tree</span> weight a)] <span class="kw">deriving</span> (<span class="dt">Show</span>, <span class="dt">Eq</span>)

<span class="co">-- Let&#39;s assume for simplicity that vertices and weights are integers</span>
<span class="ot">dfs ::</span> <span class="dt">Graph</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">ConnectedComponent</span> <span class="dt">Int</span> <span class="dt">Int</span>]
dfs g <span class="fu">=</span>
  runST <span class="fu">$</span> <span class="kw">do</span>
    vstates <span class="ot">&lt;-</span> MV.replicate (verticesCount g) <span class="dt">U</span>
    loop (vertices g) vstates
  <span class="kw">where</span>
<span class="ot">    loop ::</span> forall s<span class="fu">.</span> [<span class="dt">Int</span>]
         <span class="ot">-&gt;</span> <span class="dt">MV.MVector</span> s <span class="dt">VState</span>
         <span class="ot">-&gt;</span> <span class="dt">ST</span> s [<span class="dt">ConnectedComponent</span> <span class="dt">Int</span> <span class="dt">Int</span>]
    loop vs vstates <span class="fu">=</span> <span class="kw">do</span>
      mv <span class="ot">&lt;-</span> findNextUndiscoveredVertex vstates
      maybe (return []) processVertex mv
        <span class="kw">where</span>
          processVertex v <span class="fu">=</span>
            liftA2 (<span class="fu">:</span>) (evalStateT dfs&#39; (<span class="dt">DFSState</span> v (<span class="dt">Node</span> v []) vstates))
                       (loop vs vstates)

<span class="ot">    dfs&#39; ::</span> <span class="dt">StateT</span> (<span class="dt">DFSState</span> s <span class="dt">Int</span> <span class="dt">Int</span>) (<span class="dt">ST</span> s) (<span class="dt">ConnectedComponent</span> <span class="dt">Int</span> <span class="dt">Int</span>)
    dfs&#39; <span class="fu">=</span> <span class="kw">do</span>
      <span class="dt">DFSState</span> v tree vstates&#39; <span class="ot">&lt;-</span> get
      MV.write vstates&#39; v <span class="dt">D</span>
      tree&#39; <span class="ot">&lt;-</span> foldlM (\tree&#39; edge<span class="fu">@</span>(v&#39;, _) <span class="ot">-&gt;</span> <span class="kw">do</span>
                          vstate <span class="ot">&lt;-</span> MV.read vstates&#39; v&#39;
                          lift <span class="fu">$</span> processEdgeNode v tree&#39; vstate edge)
                      tree
                      (adjacent v g)
      MV.write vstates v <span class="dt">P</span>
      modify&#39; (\s <span class="ot">-&gt;</span> s{ dfsConnectedComponent <span class="fu">=</span> tree&#39; })
      gets dfsConnectedComponent

<span class="ot">    processEdgeNode ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">VState</span> <span class="ot">-&gt;</span> <span class="dt">EdgeNode</span> <span class="dt">Int</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">ST</span> s (<span class="dt">Tree</span> <span class="dt">Int</span> <span class="dt">Int</span>)
    processEdgeNode v tree <span class="dt">Undiscovered</span> edgeNode<span class="fu">@</span>(v&#39;, _) <span class="fu">=</span>
      evalStateT dfs&#39; (<span class="dt">DFSState</span> v&#39; (buildTree v edgeNode tree) vstates)
    processEdgeNode _ tree _ _ <span class="fu">=</span> return tree

<span class="ot">    findNextUndiscoveredVertex ::</span> forall (<span class="ot">m ::</span> <span class="fu">*</span> <span class="ot">-&gt;</span> <span class="fu">*</span>)<span class="fu">.</span> <span class="dt">PrimMonad</span> m
                               <span class="ot">=&gt;</span> <span class="dt">MV.MVector</span> (<span class="dt">PrimState</span> m) <span class="dt">VState</span>
                               <span class="ot">-&gt;</span> m (<span class="dt">Maybe</span> <span class="dt">Int</span>)
    findNextUndiscoveredVertex vstates <span class="fu">=</span>
      go <span class="dv">0</span> (MV.length vstates)
      <span class="kw">where</span>
        go idx size
          <span class="fu">|</span> idx <span class="fu">==</span> size <span class="fu">=</span> return <span class="dt">Nothing</span>
          <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">do</span>
              vstate <span class="ot">&lt;-</span> MV.read vstates idx
              <span class="kw">case</span> vstate <span class="kw">of</span>
                <span class="dt">U</span> <span class="ot">-&gt;</span> return (<span class="dt">Just</span> idx)
                _ <span class="ot">-&gt;</span> go (idx <span class="fu">+</span> <span class="dv">1</span>) size</code></pre></div>
<p>This code is possibly better than an imperative-style implementation in some aspects - for example state and side effects are now explicit and pattern matching makes the code a bit clearer in some places - but one might argue that monadic code makes the algorithm even harder to follow.</p>
<p>There <strong>must</strong> be a better way of doing this! Some online research on the subject led me to <a href="https://wiki.haskell.org/Research_papers/Data_structures#Graphs">this page</a> in the Haskell wiki that has a few links to research papers that tackle graphs and graph algorithms using a functional programming language. Two of them caught my attention and I’d like to illustrate the solutions proposed in those papers.</p>
<h2 id="functional-depth-first-search-using-adjacency-lists">Functional depth-first search using adjacency lists</h2>
<p>The first paper is titled <a href="http://citeseerx.ist.psu.edu/viewdoc/summary?doi=10.1.1.52.6526">“Structuring Depth First Search Algorithms in Haskell”</a> , written by David King’s and John Launchbury’s in 1995. The main goals of the paper are:</p>
<ol style="list-style-type: decimal">
<li>implementing depth-first search and related algorithms using a functional style without any performance penalty - this means traversing the graph in linear time</li>
<li>achieving greater code modularity</li>
<li>being able to formally prove the critical properties of the considered algorithms</li>
</ol>
<p>I would like to highlight this last aspect: it’s probably the first time I read material on graph algorithms that takes it into consideration and it can be really useful, for example in property testing. The paper approaches graph traversal as a combinatorial problem and employs a common technique in that kind of problems: generate and prune. Before illustrating the gist of that technique, let’s define some types and auxiliary functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">{-# LANGUAGE RankNTypes #-}</span>
<span class="ot">{-# LANGUAGE FlexibleContexts #-}</span>
<span class="ot">{-# LANGUAGE BangPatterns #-}</span>

<span class="kw">import </span><span class="dt">Data.Array</span> (accumArray, bounds, indices)
<span class="kw">import qualified</span> <span class="dt">Data.Array.ST</span> <span class="kw">as</span> <span class="dt">MA</span>
<span class="kw">import </span><span class="dt">Control.Monad.ST</span>

<span class="kw">type</span> <span class="dt">Table</span> <span class="fu">=</span> <span class="dt">Array</span> <span class="dt">Vertex</span>

<span class="kw">type</span> <span class="dt">Graph</span> <span class="fu">=</span> <span class="dt">Table</span> [<span class="dt">EdgeNode</span>]

<span class="co">-- Let&#39;s assume for simplicity that vertices and weights are integers</span>
<span class="kw">type</span> <span class="dt">Vertex</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">Weight</span> <span class="fu">=</span> <span class="dt">Int</span>

<span class="kw">type</span> <span class="dt">Bounds</span> <span class="fu">=</span> (<span class="dt">Vertex</span>, <span class="dt">Vertex</span>)

<span class="ot">buildG ::</span> <span class="dt">Bounds</span> <span class="ot">-&gt;</span> [(<span class="dt">Vertex</span>, <span class="dt">EdgeNode</span>)] <span class="ot">-&gt;</span> <span class="dt">Graph</span>
buildG bounds <span class="fu">=</span> accumArray (flip (<span class="fu">:</span>)) [] bounds

<span class="ot">mkEmpty ::</span> (<span class="dt">Ix</span> i, <span class="dt">MA.MArray</span> (<span class="dt">MA.STUArray</span> s) <span class="dt">Bool</span> m)
        <span class="ot">=&gt;</span> (i, i) <span class="co">-- min &amp; max bound</span>
        <span class="ot">-&gt;</span> m (<span class="dt">MA.STUArray</span> s i <span class="dt">Bool</span>)
mkEmpty bnds <span class="fu">=</span> MA.newArray bnds <span class="dt">False</span>

<span class="ot">contains ::</span> (<span class="dt">Ix</span> i, <span class="dt">MA.MArray</span> (<span class="dt">MA.STUArray</span> s) <span class="dt">Bool</span> m)
         <span class="ot">=&gt;</span> <span class="dt">MA.STUArray</span> s i <span class="dt">Bool</span> <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> m <span class="dt">Bool</span>
contains <span class="fu">=</span> MA.readArray

<span class="ot">include ::</span> (<span class="dt">Ix</span> i, <span class="dt">MA.MArray</span> a <span class="dt">Bool</span> m) <span class="ot">=&gt;</span> a i <span class="dt">Bool</span> <span class="ot">-&gt;</span> i <span class="ot">-&gt;</span> m ()
include arr v <span class="fu">=</span> MA.writeArray arr v <span class="dt">True</span></code></pre></div>
<p>Now let’s consider this very simple graph:</p>
<p><img class="figure centered" src="/images/sample_graph.png" alt="Sample graph" /></p>
<p>and let’s look at the generate and prune technique at a high level: the “generate” step describes how to create all possible trees from a given vertex. The following picture illustrates it for the sample graph above, notice that the generated tree is infinite. The nodes that are greyed-out are not yet generated and will be only if it’s necessary:</p>
<p><img class="figure centered" src="/images/generate_prune_1.png" alt="Inductive graph" /></p>
<p>The “prune” step discards the sub-trees that violate to the invariants of DFS, namely those that have already been discovered. Back to our example, when the algorithm reaches <code>b</code>, it will discard the tree with root <code>a</code> because it has been already been discovered and traverses the tree whose root is labelled <code>c</code> instead:</p>
<p><img class="figure centered" src="/images/generate_prune_3.png" alt="Inductive graph" /></p>
<p>The same thing happens after <code>c</code> is traversed leaving the final DFS spanning tree:</p>
<p><img class="figure centered" src="/images/generate_prune_4.png" alt="Inductive graph" /></p>
<p>The approach guarantees the efficiency of the algorithm because the evaluation strategy of languages with non-strict semantics (call-by-need or lazy evaluation) assures that an expression is evaluated only once and on-demand; also, the discarded trees will never be used - that is traversed - so they will never be created in the first place. Let’s have a look now at the implementation:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dfs ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Forest</span> <span class="dt">Vertex</span>
dfs g <span class="fu">=</span> prune (bounds g) <span class="fu">.</span> map (generate g)
  <span class="kw">where</span>
    <span class="co">-- create all possible trees for each vertex...</span>
<span class="ot">    generate ::</span> <span class="dt">Graph</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Tree</span> <span class="dt">Vertex</span>
    generate g v <span class="fu">=</span> <span class="dt">Node</span> v (map (generate g <span class="fu">.</span> fst) (g <span class="fu">!</span> v))

    <span class="co">-- ...and discard the ones that are unused</span>
<span class="ot">    prune ::</span> <span class="dt">Bounds</span> <span class="ot">-&gt;</span> <span class="dt">Forest</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Forest</span> <span class="dt">Vertex</span>
    prune bnds ts <span class="fu">=</span> runST <span class="fu">$</span> <span class="kw">do</span>
      s <span class="ot">&lt;-</span> mkEmpty<span class="ot"> bnds ::</span> forall s<span class="fu">.</span> <span class="dt">ST</span> s (<span class="dt">MA.STUArray</span> s <span class="dt">Vertex</span> <span class="dt">Bool</span>)
      chop ts s</code></pre></div>
<p>Notice that the type signature for the <code>mkEmpty bnds</code> is mandatory, more info can be found <a href="https://stackoverflow.com/a/9469942/">here</a>. The <code>chop</code> function discards the trees that have already been discovered:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">chop ::</span> (<span class="dt">MA.MArray</span> (<span class="dt">MA.STUArray</span> s) <span class="dt">Bool</span> m)
     <span class="ot">=&gt;</span> <span class="dt">Forest</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">MA.STUArray</span> s <span class="dt">Vertex</span> <span class="dt">Bool</span> <span class="ot">-&gt;</span> m (<span class="dt">Forest</span> <span class="dt">Vertex</span>)
chop [] _arr <span class="fu">=</span> return []
chop (<span class="dt">Node</span> v ts<span class="fu">:</span>ns) arr <span class="fu">=</span> <span class="kw">do</span>
  visited <span class="ot">&lt;-</span> contains arr v
  <span class="kw">if</span> visited
    <span class="co">-- prune ts</span>
    <span class="kw">then</span> chop ns arr
    <span class="kw">else</span> <span class="kw">do</span>
      <span class="co">-- label vertex</span>
      include arr v
      <span class="co">-- traverse left-to-right</span>
      ts&#39; <span class="ot">&lt;-</span> chop ts arr
      <span class="co">-- traverse top-to-bottom</span>
      ns&#39; <span class="ot">&lt;-</span> chop ns arr
      return <span class="fu">$</span> <span class="dt">Node</span> v ts&#39; <span class="fu">:</span> ns&#39;</code></pre></div>
<p>Two qualities of this solution that can be highlighted are:</p>
<ul>
<li>for performance reasons it uses a mutable array to keep track of the state of each vertex. The paper points out that this is not strictly necessary and if a logarithmic increase in the time complexity of the algorithm is acceptable, a <code>Set</code> data structure can be used to avoid the need for monadic code.</li>
<li>the algorithm does use a functional style but the data structure chosen to represent a graph is an <a href="https://en.wikipedia.org/wiki/Adjacency_list">adjacency list</a>, which is usually the preferred way of representing graphs in the imperative programming languages. Why this is important will become apparent in the next paragraph.</li>
</ul>
<h5 id="a-little-remark">A little remark</h5>
<p>Section “5. Implementing depth-first search” states that</p>
<blockquote>
<p>The choice of pruning patterns determines whether the forest ends up being depth-first (traverse in a left-most, top-most fashion) or breadth-first ( top-most, left-most)</p>
</blockquote>
<p>but without providing any code for it and I honestly could not wrap my head around on how to write a breadth-first traversal with the algorithm proposed in the paper. If anybody has some pointers again please <a href="/about.html">let me know</a>!</p>
<h2 id="functional-graph-algorithms-using-inductive-graphs">Functional graph algorithms using inductive graphs</h2>
<p>The second paper is Martin Erwig’s <a href="http://web.engr.oregonstate.edu/~erwig/papers/abstracts.html#JFP01">“Inductive Graphs and Functional Graph Algorithms”</a> and it was published in 2001. The main goals of the paper are:</p>
<ul>
<li>describing an inductive definition of graphs and graph algorithms as recursive functions</li>
<li>providing efficient implementations of graph algorithms that can be used in real-world scenarios</li>
<li>providing clear algorithms that can be used to teach graph algorithms</li>
</ul>
<p>At the very beginning of the paper Martin Erwig asks the following question:</p>
<blockquote>
<p>How should I implement a graph algorithm in a functional programming language?</p>
</blockquote>
<p>which was exactly the one that started my exploration of the topic. The paper acknowledges lots of the functional graph algorithms already developed but also considers them all not completely satisfactory either because they introduce constructs that are not currently available in today’s programming languages or because they entail some imperative-style strategy - i.e. keeping track of visited nodes by labelling them - that contaminates the clarity of the algorithm, makes it harder to reason about it and to prove its correctness. The solution the paper proposes is to think about graphs in a new way.</p>
<h3 id="enter-inductive-graphs">Enter inductive graphs</h3>
<p>An observation in the paper particularly caught my attention: lists and trees algorithms are much simpler and more modular than graph algorithms and do not require additional bookkeeping: why is that? The answer is two-fold: their definition and the definitions of functions on them are <em>inductive</em> and besides that <em>pattern matching</em> helps a great deal when it comes to clarity and succinctness. Now let’s have a look at the definition of graphs: they are usually defined as a pair <code>G = (V, E)</code> where <code>V</code> is the set of vertices and <code>E</code> the set of edges, where edge is defined as a pair of vertices in <code>V</code>. Imperative algorithms on graphs discover edges and vertices incrementally and usually need to keep track of the visited vertices either using a separate data structure or by storing more data in the graph itself. In this sense the usual definition of graphs is monolithic and this is the reasons why algorithms that use this API are doomed if what they strive for is clarity and modularity. Would it be possible to define graphs inductively? If so how? A valid definition for a graph data structure defined inductively might look like the following:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">infixr</span> <span class="dv">5</span> <span class="fu">:&amp;:</span>
<span class="kw">data</span> <span class="dt">Graph</span> weight label
  <span class="fu">=</span> <span class="dt">Empty</span>
  <span class="fu">|</span> (<span class="dt">Context</span> weight label) <span class="fu">:&amp;:</span> (<span class="dt">Graph</span> weight label)
  <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Context</span> weight label <span class="fu">=</span>
  ( <span class="dt">Adj</span> weight  <span class="co">-- inbound edges</span>
  , <span class="dt">Vertex</span>
  , label
  , <span class="dt">Adj</span> weight  <span class="co">-- outbound edges</span>
  )

<span class="co">-- adjacent weighted edges</span>
<span class="kw">type</span> <span class="dt">Adj</span> weight <span class="fu">=</span> [(weight, <span class="dt">Vertex</span>)]

<span class="kw">type</span> <span class="dt">Vertex</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<p>The definition should look familiar if you’ve already seen one for trees or lists: a graph is either empty or it has a context and another graph. A <code>Context</code> contains information about a given vertex, namely its value, label (if any) and its adjacent edges classified as inbound or outbound. So far so good: now taking the following graph as an example:</p>
<p><img class="figure centered" src="/images/sample_graph.png" alt="Sample graph" /></p>
<p>how can we build an inductive graph from a list of vertices and edges? One possible way of building the inductive graph would be the following:</p>
<p><img class="figure centered" src="/images/sample_inductive_graph123.png" alt="Inductive graph" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> read <span class="st">&quot;mkG [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)] [(1, 2, 5), (2, 1, 3), (2, 3, 1), (3, 1, 4)]&quot;</span>
([(<span class="dv">4</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>)],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[(<span class="dv">5</span>,<span class="dv">2</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="dv">1</span>,<span class="dv">3</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[]) <span class="fu">:&amp;:</span> <span class="dt">Empty</span>))</code></pre></div>
<p>But that’s not the only valid representation of an inductive graph, another valid inductive graph is the following:</p>
<p><img class="figure centered" src="/images/sample_inductive_graph321.png" alt="Inductive graph" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> read <span class="st">&quot;mkG [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;a&#39;, 1)] [(1, 2, 5), (2, 1, 3), (2, 3, 1), (3, 1, 4)]&quot;</span>
([(<span class="dv">1</span>,<span class="dv">2</span>)],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[(<span class="dv">4</span>,<span class="dv">1</span>)]) <span class="fu">:&amp;:</span> (([(<span class="dv">5</span>,<span class="dv">1</span>)],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="dv">3</span>,<span class="dv">1</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[]) <span class="fu">:&amp;:</span> <span class="dt">Empty</span>))</code></pre></div>
<p>At this point we can start defining some of the properties of inductive graphs:</p>
<ul>
<li>given a list of vertices and a list of edges, multiple inductive graphs can be built depending on the order of insertion of its vertices</li>
<li>equality is not defined by their “shapes” but rather by the set of vertices and edges they represent</li>
<li>the adjacent inbound and outbound edges in a <code>Context</code> are lists of vertices that have <em>already been discovered</em></li>
<li>inductive graphs are fully persistent data structures</li>
</ul>
<h3 id="active-graph-patterns">Active graph patterns</h3>
<p>Pattern matching was identified as one of the ingredients that made lists and trees algorithms clean and succinct, the paper refers to an extension of pattern matching for graphs named <em>“active graph pattern”</em> whose main goal is as far as I understood to make the notation more compact, augmenting the classic pattern matching by allowing a function to be called before the matching is applied. It is very similar to <a href="https://ghc.haskell.org/trac/ghc/wiki/ViewPatterns">view patterns</a> but it is not currently available in Haskell as far as I know; the following code is made up and <strong>will not</strong> type-check but hopefully will provide a good intuition:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">deg ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">Int</span>
deg v ((ins, _, _, outs) (<span class="fu">:&amp;:</span> <span class="fu">&lt;!&gt;</span> v) g) <span class="fu">=</span> length ins <span class="fu">+</span> length out</code></pre></div>
<p>The expression <code>(:&amp;: &lt;!&gt; v)</code> can be interpreted as: <em>“find the <code>Context</code> for the vertex <code>v</code> in the graph <code>g</code> if it exists and try to match the given pattern”</em>. Active graph patterns are not essential when implementing inductive graphs and it is possible do pattern matching without them, all that is needed is a function <code>match</code>. An extremely naive implementation might look like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">match ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">Maybe</span> (<span class="dt">Context</span> weight label, <span class="dt">Graph</span> weight label)
match qv <span class="fu">=</span> matchHelp ([], [])
  <span class="kw">where</span>
    matchHelp _ <span class="dt">Empty</span> <span class="fu">=</span> <span class="dt">Nothing</span>
    matchHelp (lvs, wes) ((ins, v, l, outs) <span class="fu">:&amp;:</span> g)
      <span class="fu">|</span> qv <span class="fu">==</span> v <span class="fu">=</span>
          <span class="co">-- rebuild the graph inserting `v` last</span>
          <span class="kw">let</span> (<span class="fu">:&amp;:</span>) <span class="fu">!</span>ctx <span class="fu">!</span>g&#39; <span class="fu">=</span> mkG g ((l, v)<span class="fu">:</span>lvs) es&#39;
          <span class="co">-- return `v`&#39;s context and the new inductive graph</span>
          <span class="kw">in</span> <span class="dt">Just</span> (ctx, g&#39;)
      <span class="fu">|</span> otherwise <span class="fu">=</span> matchHelp ((l, v)<span class="fu">:</span>lvs, es&#39;) g
      <span class="kw">where</span>
        <span class="co">-- build a list of edges to rebuild the graph</span>
        es&#39; <span class="fu">=</span>
          map (\(w, fromv) <span class="ot">-&gt;</span> (fromv, v, w)) ins
            <span class="fu">++</span> map (\(w, tov) <span class="ot">-&gt;</span> (v, tov, w)) outs
            <span class="fu">++</span> wes</code></pre></div>
<h3 id="functional-graph-algorithms">Functional graph algorithms</h3>
<p>Now that we defined graphs inductively, it’s time to show how that can be leveraged to write clear, recursive graph algorithms. Let’s have a look at some fundamental graph algorithms: depth-first search (DFS), breadth-first search (BFS), Dijkstra’s shortest path and Prims’ algorithm to find the minimum spanning tree (MST).</p>
<h4 id="depth-first-search">Depth-first search</h4>
<p>Using a depth-first search strategy to visit a graph essentially means: traverse each vertex <strong>once</strong> and visit <strong>successors before siblings</strong>. Here’s what the algorithm looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dfs ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]
dfs _ <span class="dt">Empty</span> <span class="fu">=</span> []
dfs [] _ <span class="fu">=</span> []
dfs (v<span class="fu">:</span>vs) g <span class="fu">=</span> <span class="kw">case</span> v <span class="ot">`match`</span> g <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dfs vs g
  <span class="dt">Just</span> ((_,vtx,_,outs), g&#39;) <span class="ot">-&gt;</span> vtx <span class="fu">:</span> dfs (destvs outs <span class="fu">++</span> vs) g&#39;

<span class="co">-- extracts destination vertices from the outbound edges of a context</span>
<span class="ot">destvs ::</span> <span class="dt">Context</span> label weight <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]</code></pre></div>
<p><code>dfs</code> is a recursive function that takes a list of input vertices and a graph and returns a list of vertices sorted by traversing the graph in DFS-style. If the graph or their input vertices are empty it returns the empty list, otherwise it <code>match</code>es the current vertex <code>v</code> against the graph. If <code>v</code> is a vertex in the graph, <code>match</code> will first return its context and a new graph without it, append <code>v</code> to the results list and finally the recursion will happen using as input the list of destination vertices for all outbound edges of <code>v</code> appended to the remaining input vertices and the new graph returned by the <code>match</code> function; if <code>v</code> is not a vertex in the graph then it is simply ignored. There key observations about the algorithm are:</p>
<ol style="list-style-type: decimal">
<li>destination vertices are appended <em>to the left end</em> of the input vertices: this is what makes the algorithm traversing the input graph depth-first. This is exactly what the second invariant of DFS dictates: visit successors before siblings.</li>
<li>the <code>match</code> function returns a new graph <em>without</em> the query vertex: this is what the first invariant of DFS dictates: visit each vertex exactly once. Since the new graph doesn’t contain the query vertex there is no need for keeping track of the visited vertices therefore no bookkeeping is necessary.</li>
</ol>
<p>Let’s have a look at a very simple example using one of the sample graphs above:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> <span class="kw">let</span> g <span class="fu">=</span> read <span class="st">&quot;mkG [(&#39;c&#39;, 3), (&#39;b&#39;, 2), (&#39;a&#39;, 1)] [(1, 2, 5), (2, 1, 3), (2, 3, 1), (3, 1, 4)]&quot;</span>
([(<span class="dv">1</span>,<span class="dv">2</span>)],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[(<span class="dv">4</span>,<span class="dv">1</span>)]) <span class="fu">:&amp;:</span> (([(<span class="dv">5</span>,<span class="dv">1</span>)],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="dv">3</span>,<span class="dv">1</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[]) <span class="fu">:&amp;:</span> <span class="dt">Empty</span>))
ƛ<span class="fu">:</span> dfs (vertices g) g
[<span class="dv">1</span>, <span class="dv">2</span>, <span class="dv">3</span>]</code></pre></div>
<p>One of the applications of DFS is finding the spanning forest (set of trees) of a graph. The algorithm needs to build the spanning forest by traversing the graph in such a way that only when DFS traversal is completed for a <a href="https://en.wikipedia.org/wiki/Connected_component_(graph_theory)">connected component</a> it will proceed with the next one. Let’s define some types first:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">data</span> <span class="dt">Tree</span> a <span class="fu">=</span> <span class="dt">Nil</span> <span class="fu">|</span> <span class="dt">Node</span> <span class="fu">!</span>a (<span class="dt">Forest</span> a) <span class="kw">deriving</span> <span class="dt">Show</span>

<span class="kw">type</span> <span class="dt">Forest</span> a <span class="fu">=</span> [<span class="dt">Tree</span> a]

<span class="ot">dff ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">Forest</span> <span class="dt">Vertex</span>
dff vs g <span class="fu">=</span> fst (dff&#39; vs g)</code></pre></div>
<p>The <code>dff</code> function calls an auxiliary function <code>dff'</code> that does the heavy lifting, let’s have a look at it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dff&#39; ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> (<span class="dt">Forest</span> <span class="dt">Vertex</span>, <span class="dt">Graph</span> weight label)
dff&#39; [] g <span class="fu">=</span> ([], g)
dff&#39; (v<span class="fu">:</span>vs) g <span class="fu">=</span> <span class="kw">case</span> v <span class="ot">`match`</span> g <span class="kw">of</span>
  <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dff&#39; vs g
  <span class="dt">Just</span> (ctx, g&#39;) <span class="ot">-&gt;</span> (<span class="dt">Node</span> v ts <span class="fu">:</span> forest, g&#39;&#39;)
  <span class="kw">where</span>
    (ts, (forest, g&#39;&#39;)) <span class="fu">=</span> <span class="kw">let</span> (_,g&#39;&#39;) <span class="fu">=</span> dff&#39; (destvs ctx) g&#39; <span class="kw">in</span> (ts, dff&#39; vs g&#39;&#39;)
    <span class="co">-- or more succinctly: (ts, (forest, g&#39;&#39;)) = second (dff&#39; vs) (dff&#39; (destvs ctx) g&#39;)</span>
    <span class="co">-- `second` applies the function `dff&#39; vs` to the second element of</span>
    <span class="co">-- the pair returned by `dff&#39; (destvs ctx) g&#39;`</span>

<span class="co">-- extracts destination vertices from the outbound edges of a context</span>
<span class="ot">destvs ::</span> <span class="dt">Context</span> label weight <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]</code></pre></div>
<p>The <code>dff'</code> function is another recursive function: if <code>match</code>ing the vertex <code>v</code> with the graph <code>g</code> succeeds, <code>dff'</code> calls itself passing its siblings and the new graph as arguments until the list of vertices is empty; when the list is empty the recursion continues for the remaining vertices <code>vs</code> and the most recent version of the graph. Again let’s have a look at a very simple example built on top of the previous one:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> <span class="kw">let</span> g <span class="fu">=</span> read <span class="st">&quot;mkG [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5)] [(1, 2, 5), (2, 1, 3), (2, 3, 1), (3, 1, 4), (4, 5, 7)]&quot;</span><span class="ot"> ::</span> <span class="dt">Graph</span> <span class="dt">Int</span> <span class="dt">Char</span>
([(<span class="dv">4</span>,<span class="dv">3</span>),(<span class="dv">3</span>,<span class="dv">2</span>)],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[(<span class="dv">5</span>,<span class="dv">2</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="dv">1</span>,<span class="dv">3</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[]) <span class="fu">:&amp;:</span> (([],<span class="dv">4</span>,<span class="ch">&#39;d&#39;</span>,[(<span class="dv">7</span>,<span class="dv">5</span>)]) <span class="fu">:&amp;:</span> (([],<span class="dv">5</span>,<span class="ch">&#39;e&#39;</span>,[]) <span class="fu">:&amp;:</span> <span class="dt">Empty</span>))))
ƛ<span class="fu">:</span> dff (vertices g) g
[<span class="dt">Node</span> <span class="dv">1</span> [<span class="dt">Node</span> <span class="dv">2</span> [<span class="dt">Node</span> <span class="dv">3</span> []]], <span class="dt">Node</span> <span class="dv">4</span> [<span class="dt">Node</span> <span class="dv">5</span> []]]</code></pre></div>
<h4 id="breadth-first-search">Breadth-first search</h4>
<p>Using a breadth-first search strategy to visit a graph essentially means: traverse each vertex <strong>once</strong> and visit <strong>siblings before successors</strong>. Here’s what the algorithm looks like:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bfs ::</span> [<span class="dt">Vertex</span>] <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]
bfs vs g <span class="fu">=</span>
  <span class="fu">|</span> isEmpty g <span class="fu">||</span> null vs <span class="fu">=</span> []
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> v <span class="ot">`match`</span> g <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> bfs g vs&#39;
      <span class="dt">Just</span> (ctx, g&#39;) <span class="ot">-&gt;</span> v <span class="fu">:</span> bfs g&#39; (vs&#39; <span class="fu">++</span> destvs ctx)

    (v, vs&#39;) <span class="fu">=</span> (head vs, tail vs)

<span class="co">-- extracts destination vertices from the outbound edges of a context</span>
<span class="ot">destvs ::</span> <span class="dt">Context</span> label weight <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]</code></pre></div>
<p>There key facts to notice about the algorithm are:</p>
<ol style="list-style-type: decimal">
<li>siblings are appended <em>at the right end of</em> the input vertices: this is what makes the algorithm traversing the input graph breadth-first. This is exactly what the second invariant of BFS dictates : visit siblings before the successor.</li>
<li>the <code>match</code> function returns a new graph <em>without</em> the current vertex: this is what the first invariant of BFS dictates: traverse each vertex exactly once. Since the new graph doesn’t contain the current vertex there is no need for keeping track of the visited vertices.</li>
<li>the algorithm is mostly the same as <code>dfs</code>, the only thing that changes is where siblings are appended: in case of BFS they’re appended at the end of the list, in case of DFS in front of it. To fully appreciate this it might be useful to think of these algorithms in terms of the data structures they use: LIFO in case of DFS and a FIFO in case of BFS.</li>
</ol>
<p>One of the applications of BFS is finding the shortest path in a unweighted graph. For convenience the paper chooses a different representation for the spanning forest: a list of labelled paths. Let’s have a look at the implementation of the shortest path algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">type</span> <span class="dt">Path</span> <span class="fu">=</span> [<span class="dt">Vertex</span>]

<span class="co">-- Roots tree</span>
<span class="kw">type</span> <span class="dt">RTree</span> <span class="fu">=</span> [<span class="dt">Path</span>]

<span class="ot">shortestPath ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">Path</span>
shortestPath src dst <span class="fu">=</span> reverse <span class="fu">.</span> pathTo ((<span class="fu">==</span>dst) <span class="fu">.</span> head) <span class="fu">.</span> bft src

<span class="ot">pathTo ::</span> (a <span class="ot">-&gt;</span> <span class="dt">Bool</span>) <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> a
pathTo p <span class="fu">=</span> head <span class="fu">.</span> filter p</code></pre></div>
<p>The <code>esp</code> function requires a source vertex and a destination vertex, filters the path to the destination and reverses it (why this is necessary will become clear in a moment). Notice that since Haskell has non-strict semantics, <code>esp</code> stops as soon as the path to the target destination vertex is found. Now let’s have a look at the implementation of the <code>bft</code> function:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">bft ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">RTree</span>
bft v <span class="fu">=</span>  bf [[v]]

<span class="ot">bf ::</span> [<span class="dt">Path</span>] <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">RTree</span>
bf paths <span class="fu">=</span> bf&#39; paths
  <span class="kw">where</span>
<span class="ot">    bf&#39; ::</span> [<span class="dt">Path</span>] <span class="ot">-&gt;</span> <span class="dt">Graph</span> weight label <span class="ot">-&gt;</span> <span class="dt">RTree</span>
    bf&#39; paths g
      <span class="fu">|</span> null paths <span class="fu">||</span> isEmpty g <span class="fu">=</span> []
      <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> v <span class="ot">`match`</span> g <span class="kw">of</span>
          <span class="dt">Nothing</span> <span class="ot">-&gt;</span> bf&#39; paths&#39; g
          <span class="dt">Just</span> ((_,_,_,outs), g&#39;) <span class="ot">-&gt;</span> path <span class="fu">:</span> bf&#39; (paths&#39; <span class="fu">++</span> map (<span class="fu">:</span>path) (destvs outs)) g&#39;

    <span class="co">-- gets the current vertex from the first path in the list and the remaining paths</span>
    <span class="co">-- paths will never be empty because `bf` is called using a non-empty list</span>
    (path<span class="fu">@</span>(v<span class="fu">:</span>_), paths&#39;) <span class="fu">=</span> <span class="kw">let</span> (pss, pss&#39;) <span class="fu">=</span> splitAt <span class="dv">1</span> paths <span class="kw">in</span> (head pss, pss&#39;)
    <span class="co">-- more succinctly: (path@(v:_), paths&#39;) = first head (splitAt 1 paths)</span>

<span class="co">-- extracts destination vertices from the outbound edges of a context</span>
<span class="ot">destvs ::</span> <span class="dt">Context</span> label weight <span class="ot">-&gt;</span> [<span class="dt">Vertex</span>]</code></pre></div>
<p>Instead of explaining what the function does step-by-step, let’s have a look at an example on a simple graph as it might be easier to understand:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> <span class="kw">let</span> g <span class="fu">=</span> read <span class="st">&quot;mkG [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3)] [(1, 2, ()), (2, 1, ()), (2, 3, ()), (3, 1, ())]&quot;</span><span class="ot"> ::</span> <span class="dt">Graph</span> () <span class="dt">Char</span>
([(<span class="dv">4</span>,()),(<span class="dv">3</span>,())],<span class="dv">1</span>,<span class="ch">&#39;a&#39;</span>,[(<span class="dv">5</span>,())]) <span class="fu">:&amp;:</span> (([],<span class="dv">2</span>,<span class="ch">&#39;b&#39;</span>,[(<span class="dv">1</span>,())]) <span class="fu">:&amp;:</span> (([],<span class="dv">3</span>,<span class="ch">&#39;c&#39;</span>,[]) <span class="fu">:&amp;:</span> <span class="dt">Empty</span>))
ƛ<span class="fu">:</span> bf [[<span class="dv">1</span>]] g
[[<span class="dv">1</span>],[<span class="dv">2</span>,<span class="dv">1</span>],[<span class="dv">3</span>,<span class="dv">2</span>,<span class="dv">1</span>]]</code></pre></div>
<p>Notice that an unweighted graph is a graph whose weight is <code>()</code> and that the resulting spanning tree contains the shortest path from the source vertex to all other vertices in <em>reverse order</em>. The <code>bf</code> function builds complete paths from a source to a destination vertex but doesn’t waste any memory because list prefixes are shared.</p>
<h4 id="dijkstras-shortest-path">Dijkstra’s shortest path</h4>
<p>Finding the shortest path between two vertices means finding the cheapest path between them (where “cheap” is dependent upon the weight or cost of the edges). Dijkstra’s algorithm to find the shortest path in a weighted graph essentially chooses always the next cheapest edge taking into account the distance traversed so far. First let’s define two new auxiliary types:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- Labelled vertex</span>
<span class="kw">type</span> <span class="dt">LVertex</span> label <span class="fu">=</span> (label, <span class="dt">Vertex</span>)

<span class="co">-- Only needed to be able to define `Eq` and `Ord` instances</span>
<span class="kw">newtype</span> <span class="dt">LPath</span> label <span class="fu">=</span> <span class="dt">LPath</span> {<span class="ot"> getLPath ::</span> [<span class="dt">LVertex</span> label] }

<span class="co">-- Labelled R-Tree (or Root Tree)</span>
<span class="kw">type</span> <span class="dt">LRTree</span> label <span class="fu">=</span> [<span class="dt">LPath</span> label]

<span class="kw">instance</span> <span class="dt">Eq</span> label <span class="ot">=&gt;</span> <span class="dt">Eq</span> (<span class="dt">LPath</span> label) <span class="kw">where</span> <span class="fu">...</span>

<span class="kw">instance</span> <span class="dt">Ord</span> label <span class="ot">=&gt;</span> <span class="dt">Ord</span> (<span class="dt">LPath</span> label) <span class="kw">where</span> <span class="fu">...</span>

<span class="kw">type</span> <span class="dt">Weight</span> <span class="fu">=</span> <span class="dt">Int</span></code></pre></div>
<p>The algorithm uses a min-heap and some auxiliary functions to keep track of the cheapest path:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="kw">import qualified</span> <span class="dt">Data.Heap</span> <span class="kw">as</span> <span class="dt">Heap</span>

<span class="ot">getPath ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">LRTree</span> label <span class="ot">-&gt;</span> <span class="dt">Path</span>
getPath v <span class="fu">=</span> reverse <span class="fu">.</span> map snd <span class="fu">.</span> getLPath <span class="fu">.</span> pathTo ((<span class="fu">==</span>v) <span class="fu">.</span> lv2v)
  <span class="kw">where</span>
    lv2v <span class="fu">=</span> snd <span class="fu">.</span> head <span class="fu">.</span> getLPath

<span class="ot">expand ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">LPath</span> <span class="dt">Weight</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> [<span class="dt">LPath</span> <span class="dt">Weight</span>]
expand d (<span class="dt">LPath</span> p) (_, _, _, outs) <span class="fu">=</span> map (\(w, v) <span class="ot">-&gt;</span> <span class="dt">LPath</span> ((w <span class="fu">+</span> d, v)<span class="fu">:</span>p)) outs

<span class="ot">mergeAll ::</span> [<span class="dt">LVertex</span> <span class="dt">Weight</span>] <span class="ot">-&gt;</span> <span class="dt">Heap.Heap</span> (<span class="dt">LPath</span> <span class="dt">Weight</span>) <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">Heap.Heap</span> (<span class="dt">LPath</span> <span class="dt">Weight</span>)
mergeAll p<span class="fu">@</span>((dist, _)<span class="fu">:</span>_) h ctx <span class="fu">=</span> foldr Heap.insert h (expand dist (<span class="dt">LPath</span> p) ctx)</code></pre></div>
<p>The <code>expand</code> function builds new <code>LPath</code>s whose label is the sum of the distance walked so far - let’s assume weights are positive integers for simplicity - and the weight of the outbound edge. The <code>mergeAll</code> function takes these paths and inserts them in the heap. The <code>getPath</code> function just extracts the path to the given destination vertex from the list of paths. Now let’s have a look at the core of the algorithm:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">dijkstra ::</span> <span class="dt">Heap.Heap</span> (<span class="dt">LPath</span> <span class="dt">Weight</span>) <span class="ot">-&gt;</span> <span class="dt">Graph</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">LRTree</span> <span class="dt">Weight</span>
dijkstra h g
  <span class="fu">|</span> isEmpty g <span class="fu">=</span> []
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> Heap.viewMin h <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []
      <span class="dt">Just</span> (lpath, h&#39;) <span class="ot">-&gt;</span> dijkstra&#39; (lpath, h&#39;)
  <span class="kw">where</span>
    dijkstra&#39; (<span class="dt">LPath</span> p<span class="fu">@</span>((_, v)<span class="fu">:</span>_), h&#39;) <span class="fu">=</span>
      <span class="kw">case</span> v <span class="ot">`match`</span> g <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> dijkstra h&#39; g
        <span class="dt">Just</span> (ctx, g&#39;) <span class="ot">-&gt;</span> <span class="dt">LPath</span> p <span class="fu">:</span> dijkstra (mergeAll p h&#39; ctx) g&#39;

<span class="ot">shortestPathTree ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">LRTree</span> <span class="dt">Weight</span>
shortestPathTree src <span class="fu">=</span> dijkstra (Heap.singleton <span class="fu">$</span> <span class="dt">LPath</span> [(mempty, src)])

<span class="ot">shortestPath ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">Path</span>
shortestPath src dst g <span class="fu">=</span> getPath dst (shortestPathTree src g)</code></pre></div>
<p>The <code>sp</code> function kicks off the algorithm by providing the source node to the <code>spt</code> function which in turn calls <code>dijkstra</code> with a singleton min-heap that contains a path to the source vertex with weight zero - this is how expensive it is to walk from the source vertex to the source vertex. The <code>dijkstra</code> function is a recursive function that peeks the cheapest path from the min-heap, and if the current vertex <code>v</code> is contained in the graph - that is, the vertex hasn’t been already visited - appends it to the resulting <code>LRTree</code> and calls itself recursively with a new min-heap that contains up-to-date costs and a new graph that doesn’t contain <code>v</code>. The recursion stops if the graph is empty - that is all vertices has been visited - or the min-heap is empty - that is all edges have been traversed. This is definitely a bit more complex than the other algorithms but it’s quite elegant and modular. Let’s have a look at an example on the following graph:</p>
<p><img class="figure centered" src="/images/sample_graph2.png" alt="Sample graph 2" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> <span class="kw">let</span> g <span class="fu">=</span> read <span class="st">&quot;mkG [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5), (&#39;f&#39;, 6), (&#39;g&#39;, 7)] [(1,2,12),(1,3,7),(1,4,5),(2,3,4),(2,7,7),(3,4,9),(3,5,4),(3,7,3),(4,5,7),(5,6,5),(5,7,2),(6,7,2)]&quot;</span><span class="ot"> ::</span> <span class="dt">Graph</span> <span class="dt">Int</span> <span class="dt">Char</span>
<span class="co">-- weights should be wrapped in a `Sum` constructor to form a monoid for addition on Ints but let&#39;s forget about that for the sake of simplicity</span>
<span class="co">-- `undir` simply transforms a directed graph to an undirected one</span>
ƛ<span class="fu">:</span> shortestPathTree <span class="dv">1</span> (undir g)
[<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">7</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">10</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">11</span>,<span class="dv">5</span>),(<span class="dv">7</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">11</span>,<span class="dv">2</span>),(<span class="dv">7</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">12</span>,<span class="dv">6</span>),(<span class="dv">10</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">3</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]}]
ƛ<span class="fu">:</span> shortestPath <span class="dv">1</span> <span class="dv">6</span> (undir g)
[<span class="dv">1</span>,<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">6</span>]</code></pre></div>
<p><img class="figure centered" src="/images/dijkstra.png" alt="Dijkstra's shortest path" /></p>
<h4 id="minimum-spanning-tree">Minimum spanning tree</h4>
<p>Prim’s algorithm to find the minimum spanning tree (MST) always traverses the cheapest edge among the discovered edges - like Dijkstra’s it’s a greedy algorithm. The two algorithms are notoriously very similar and this becomes evident using recursive functions. We’ll re-use the same types defined for the shortest path algorithm but define different auxiliary functions:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mergeAll ::</span> [<span class="dt">LVertex</span> <span class="dt">Weight</span>] <span class="ot">-&gt;</span> <span class="dt">Heap.Heap</span> (<span class="dt">LPath</span> <span class="dt">Weight</span>) <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">Heap.Heap</span> (<span class="dt">LPath</span> <span class="dt">Weight</span>)
mergeAll lvs h ctx <span class="fu">=</span> foldr Heap.insert h (addEdges (<span class="dt">LPath</span> lvs) ctx)

<span class="ot">addEdges ::</span> <span class="dt">LPath</span> <span class="dt">Weight</span> <span class="ot">-&gt;</span> <span class="dt">Context</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> [<span class="dt">LPath</span> <span class="dt">Weight</span>]
addEdges (<span class="dt">LPath</span> p) (_, _, _, outs) <span class="fu">=</span> map (<span class="dt">LPath</span> <span class="fu">.</span> (<span class="fu">:</span>p)) outs</code></pre></div>
<p>The <code>addEdges</code> function is very similar to the <code>expand</code> function but it doesn’t take into account the distance walked so far, only the weight of the edges. The core of the algorithm shouldn’t be anything new:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">prim ::</span> <span class="dt">Heap.Heap</span> (<span class="dt">LPath</span> <span class="dt">Weight</span>) <span class="ot">-&gt;</span> <span class="dt">Graph</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">LRTree</span> <span class="dt">Weight</span>
prim h g
  <span class="fu">|</span> isEmpty g <span class="fu">=</span> []
  <span class="fu">|</span> otherwise <span class="fu">=</span> <span class="kw">case</span> Heap.viewMin h <span class="kw">of</span>
      <span class="dt">Nothing</span> <span class="ot">-&gt;</span> []
      <span class="dt">Just</span> (lpath, h&#39;) <span class="ot">-&gt;</span> prim&#39; lpath h&#39;
  <span class="kw">where</span>
    prim&#39; (<span class="dt">LPath</span> p<span class="fu">@</span>((_, v)<span class="fu">:</span>_), h&#39;) <span class="fu">=</span>
      <span class="kw">case</span> v <span class="ot">`match`</span> g <span class="kw">of</span>
        <span class="dt">Nothing</span> <span class="ot">-&gt;</span> prim h&#39; g
        <span class="dt">Just</span> (ctx, g&#39;) <span class="ot">-&gt;</span> <span class="dt">LPath</span> p <span class="fu">:</span> prim (mergeAll p h&#39; ctx) g&#39;)

<span class="ot">mst ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Graph</span> <span class="dt">Weight</span> label <span class="ot">-&gt;</span> <span class="dt">LRTree</span> <span class="dt">Weight</span>
mst src <span class="fu">=</span> prim (Heap.singleton (<span class="dt">LPath</span> [(<span class="dv">0</span>, src)]))</code></pre></div>
<p>Now that the MST can be build, let’s find the path between two vertices:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="ot">mstPath ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">LRTree</span> weight <span class="ot">-&gt;</span> <span class="dt">Path</span>
mstPath src dst t <span class="fu">=</span> joinPaths (getPath src t) (getPath dst t)

<span class="ot">joinPaths ::</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Path</span>
joinPaths p2src p2dst <span class="fu">=</span> joinAt (head p2src) (tail p2src) (tail p2dst)

<span class="ot">joinAt ::</span> <span class="dt">Vertex</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Path</span> <span class="ot">-&gt;</span> <span class="dt">Path</span>
joinAt _src (v<span class="fu">:</span>vs) (v&#39;<span class="fu">:</span>vs&#39;)
  <span class="fu">|</span> v <span class="fu">==</span> v&#39; <span class="fu">=</span> joinAt v vs vs&#39;
joinAt src ps ps&#39; <span class="fu">=</span> reverse ps <span class="fu">++</span> (src<span class="fu">:</span>ps&#39;)</code></pre></div>
<p>Let’s again have a look at an example on the following graph:</p>
<p><img class="figure centered" src="/images/sample_graph2.png" alt="Sample graph 2" /></p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ<span class="fu">:</span> <span class="kw">let</span> g <span class="fu">=</span> read <span class="st">&quot;mkG [(&#39;a&#39;, 1), (&#39;b&#39;, 2), (&#39;c&#39;, 3), (&#39;d&#39;, 4), (&#39;e&#39;, 5), (&#39;f&#39;, 6), (&#39;g&#39;, 7)] [(1,2,12),(1,3,7),(1,4,5),(2,3,4),(2,7,7),(3,4,9),(3,5,4),(3,7,3),(4,5,7),(5,6,5),(5,7,2),(6,7,2)]&quot;</span><span class="ot"> ::</span> <span class="dt">Graph</span> <span class="dt">Int</span> <span class="dt">Char</span>
<span class="co">-- weights should be wrapped in a `Sum` constructor to form a monoid for addition on Ints but let&#39;s forget about that for the sake of simplicity</span>
ƛ<span class="fu">:</span> <span class="kw">let</span> mstTrees <span class="fu">=</span> mst <span class="dv">1</span> (undir g)
[<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">7</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">2</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">2</span>,<span class="dv">6</span>),(<span class="dv">2</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]},<span class="dt">LPath</span> {getLPath <span class="fu">=</span> [(<span class="dv">4</span>,<span class="dv">2</span>),(<span class="dv">3</span>,<span class="dv">3</span>),(<span class="dv">2</span>,<span class="dv">7</span>),(<span class="dv">7</span>,<span class="dv">5</span>),(<span class="dv">5</span>,<span class="dv">4</span>),(<span class="dv">0</span>,<span class="dv">1</span>)]}]
ƛ<span class="fu">:</span> mstPath <span class="dv">3</span> <span class="dv">5</span> mstTrees
[<span class="dv">3</span>,<span class="dv">7</span>,<span class="dv">5</span>]</code></pre></div>
<p><img class="figure centered" src="/images/prim.png" alt="Prim's MST" /></p>
<h2 id="a-quick-word-on-efficiency">A quick word on efficiency</h2>
<p>I mentioned that inductive graphs and related algorithms are meant to be as efficient as the non-inductive counterparts. The implementations shown so far are not - and they were not meant to be in the first place - but hopefully they provided a good intuition about inductive graphs. An efficient implementation would rely internally on more efficient data structures, and a key aspect to achieve asymptotically optimal running times for the algorithms shown above is that active patterns must execute in constant time. The <a href="https://www.stackage.org/lts-9.14/package/fgl-5.5.3.1">fgl</a> library is a real-world implementation based on Martin Erwig’s paper, and if you’re curious to know how it is possible to implement inductive graphs efficiently I’ll encourage to look at the source code; digging into the internals of the library is a whole different topic, possibly for a future blog post.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<p>One of the trade-offs to achieve clear and elegant graph algorithms seemed to be shifting the complexity from the algorithm itself to the supporting data structures: for example implementing an inductive graph is more complex than implementing an adjacency list, and using a min-heap in the shortest path or MST algorithms eliminates the need for bookkeeping when deciding which edge should be traversed next.</p>
<p>This exploration into graphs and related algorithms in functional programming started with a simple question that was surprisingly hard to answer: <em>“How should I implement a graph algorithm in a functional programming language?”</em> The plethora of resources about graphs in the imperative world is not matched in the functional world, where adequate solutions to the problem have surfaced only in the last 20 years. Starting with an unsatisfactory monadic implementation, we had a look at a better solution that leverages a mix of functional and imperative constructs and finally described an implementation based on inductive graphs that manages to be elegant, clear and efficient - with some caveats - by leveraging inductive data structures and functions.</p>
<h4 id="updates">Updates</h4>
<ul>
<li>This blog post is an expanded version of a <a href="https://prezi.com/p/jplozqursbfo/">presentation</a> I gave at the <a href="https://www.meetup.com/berlinhug/events/wfhdrnywpbtb/">Berlin Haskell User Group</a> in November 2017 where I gathered lots of valuable feedback that made it into this post. A special thanks goes to Matthias, Ben &amp; Adrian.</li>
<li>Fixed <code>bfs</code> implementation and rewordings based on <a href="https://www.perimeterinstitute.ca/personal/eschnetter/">Erik</a>’s feedback</li>
</ul>]]></summary>
</entry>
<entry>
    <title>Building slim Docker images for Haskell applications</title>
    <link href="https://futtetennismo.me/posts/docker/2017-11-24-docker-haskell-executables.html" />
    <id>https://futtetennismo.me/posts/docker/2017-11-24-docker-haskell-executables.html</id>
    <published>2017-11-24T00:00:00Z</published>
    <updated>2017-11-24T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Providing an application as a <a href="https://www.infoq.com/articles/docker-executable-images">Docker executable image</a> is a handy way to distribute an application: no need to install toolchains, frameworks and dependencies. One can just pull a Docker image and run it. It’s really that simple. Docker images can grow wildly in size because they need to install all the dependecies needed to run the application: this as a user can be quite annoying. Imagine you want to use a tiny application that solves a very specific problem and you have to download a 2GB Docker image! It’s undesirable. And it’s actually not needed: why not shipping only the executable in a very compact Docker image? How can this be achieved if the application is built in Haskell?</p>
<!--more-->
<p>I faced the problem I while ago while working on a <a href="https://github.com/futtetennista/ServerlessValidator">pet-project</a>: the Docker image was almost 2GB(!) but the only thing the application was doing was validating a YAML file. I didn’t find a good solution until a few days ago the <a href="http://feram.io/">feram.io</a> folks pointed me to this <a href="https://blog.alexellis.io/mutli-stage-docker-builds/">blog post</a> (thanks guys!). Multi-stage builds?!…I didn’t even know that was possible! So I got back to my pet-project and see how that would work out in Haskell (the application in the blog post is written in Go lang). The final solution I ended up implementing after some painful and time-consuming trial and error was a bit more involved than what is described in that post but it was worthy: the final size of the <a href="https://hub.docker.com/r/futtetennista/serverless-validator/">Docker image</a> dropped <strong>from 2GB to 17.1MB - 5MB compressed size!</strong> I first used plain multi-stage builds but that had an issue: since all the Haskell dependencies have to be compiled, the first part of the multi-stage build was taking a long time to complete while the second part was taking only a few seconds. For this reason I ended up splitting the two, basically going back to the builder patter the blog post mentions: I first built a base image with all needed Haskell dependencies compiled and than used a multi-stage build to create the executable image. The <code>Dockerfile</code> for the base image is not that interesting:</p>
<div class="sourceCode"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span class="co"># Dockerfile.builder</span>
<span class="co"># docker build -t futtetennista/serverless-validator-builder --file Dockerfile.builder .</span>
<span class="kw">FROM</span> haskell:8.0

<span class="co"># Install dependecies needed to compile Haskell libraries</span>
<span class="kw">RUN</span> apt-get update &amp;&amp; apt-get install --yes \
    xz-utils \
    make

<span class="kw">RUN</span> stack --resolver lts-9.14 install base \
    protolude \
    text \
    aeson \
    yaml \
    unordered-containers \
    case-insensitive \
    regex-compat</code></pre></div>
<p>It just installs some Linux dependencies and builds the Haskell dependencies. The one for the executable image is a bit more exciting:</p>
<div class="sourceCode"><pre class="sourceCode dockerfile"><code class="sourceCode dockerfile"><span class="co"># Dockerfile</span>
<span class="co"># docker build -t futtetennista/serverless-validator .</span>
<span class="kw">FROM</span> futtetennista/serverless-validator-builder as builder

<span class="kw">WORKDIR</span> <span class="st">&quot;/home/serverless-validator/&quot;</span>

<span class="co"># copy the contents of the current directory in the working directory</span>
<span class="kw">COPY</span> . .

<span class="kw">RUN</span> stack --resolver lts-9.14 install &amp;&amp; \
    strip /root/.local/bin/serverless-validator


<span class="kw">FROM</span> fpco/haskell-scratch:integer-gmp

<span class="kw">COPY</span> --from=builder /root/.local/bin/serverless-validator /bin/

<span class="kw">ENTRYPOINT</span> [<span class="st">&quot;/bin/serverless-validator&quot;</span>]</code></pre></div>
<p>First it compiles and links the executable in the base container, removes some unwanted piece of data as <code>man strip</code> illustrates</p>
<blockquote>
<p>strip removes or modifies the symbol table attached to the output of the assembler and link editor. This is useful to save space after a program has been debugged and to limit dynamically bound symbols.</p>
</blockquote>
<p>and finally copies the executable from the base container to the executable container. The <a href="https://hub.docker.com/r/fpco/haskell-scratch/">fpco/haskell-scratch</a> Docker image was created by a personal Haskell-hero of mine, <a href="https://twitter.com/snoyberg">Michael Snoyberg</a> and introduced in this <a href="https://www.fpcomplete.com/blog/2015/05/haskell-web-server-in-5mb">blog post</a> a while back. It’s a minimal Linux image (~2MB) that can be used as a base image to run Haskell applications; the image hasn’t been updated in two years but it still works flawlessly (there is another Docker image tagged <a href="https://hub.docker.com/r/snoyberg/haskell-scratch/">snoyberg/haskell-scratch</a> but I guess it has been deprecated).</p>
<p>Thanks once again to Michael and the FP Complete folks for solving <strong>so</strong> many practical problems Haskellers face in their day-to-day coding!</p>
<h4 id="update">UPDATE</h4>
<p>This technique is applicable whenever your application needs to build upon an existing framework or library: for example this very website! Building it on CircleCI without any caching and compiling all needed dependencies took almost <a href="https://circleci.com/gh/futtetennista/futtetennista.github.io/136">14 minutes</a>, with caching that went down to <a href="https://circleci.com/gh/futtetennista/futtetennista.github.io/141">1:32 minutes</a> and with a base image with pre-compiled dependencies to <a href="https://circleci.com/gh/futtetennista/futtetennista.github.io/143">1:18 minutes</a>.</p>]]></summary>
</entry>
<entry>
    <title>Connecting to a dockerised postgres instance via psql using user-defined bridge networks</title>
    <link href="https://futtetennismo.me/posts/docker/2017-11-15-docker-postgres.html" />
    <id>https://futtetennismo.me/posts/docker/2017-11-15-docker-postgres.html</id>
    <published>2017-11-15T00:00:00Z</published>
    <updated>2017-11-15T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Docker containers can commmunicate with each other either using the deprecated links machinery or using user-defined networks. The latter also is the way to go when using <code>docker-compose</code> since a user-defined network is created by default (at least in recent versions). <!--more--></p>
<p>The postgres official image on <a href="https://hub.docker.com/_/postgres/">Docker Hub</a> contains an example for the former case: when creating the container running the <code>psql</code> command using the default <code>bridge</code> network interface, we need to supply the <code>--link</code> option with the name (and optionally alias) of the postgres instance and the <code>--host</code> option with its <strong>alias</strong> (if no alias is supplied the name is also the alias):</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">docker</span> run -it --rm --link=postgres:postgres-instance postgres psql --host=postgres-instance --username=postgres</code></pre></div>
<p>There is no example for the latter case though, so let’s see how it can be achieved. First let’s create a user-defined network and give it an arbitrary name - i.e. <code>my_bridge</code> - by simply typing: <code>docker network create my_bridge</code>. When using user-defined networks is essential to know the <strong>IP</strong> of the container running the postgres instance, this can be retrieved like this:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">docker</span> run -itd --name=postgres-instance postgres <span class="co"># Make sure there&#39;s an instance running</span>
$ <span class="ex">docker</span> inspect --format=<span class="st">&#39;{{ .NetworkSettings.Networks.my_bridge.IPAddress }}&#39;</span> postgres-instance
<span class="ex">172.19.0.2</span></code></pre></div>
<p>Now let’s create another container that connects to the postgres instance and runs the <code>psql</code> command, and use the configuration options to set the user-defined network and to provide the IP of the postgres instance the container has to connect to:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">docker</span> run -it --rm --network=my_bridge postgres psql --host=172.19.0.2 --username=postgres</code></pre></div>
<p>Alternatively, if we leverage the <code>--add-host</code> option, the command is going to look very similar to the one we used when connecting containers using links:</p>
<div class="sourceCode"><pre class="sourceCode bash"><code class="sourceCode bash">$ <span class="ex">docker</span> run -it --rm --network=my_bridge --add-host=postgres-instance:172.19.0.2 postgres psql --host=postgres-instance --username=postgres</code></pre></div>
<p>The <code>--add-host</code> option simply adds an entry to the <code>/etc/hosts</code> file of the container.</p>]]></summary>
</entry>
<entry>
    <title>Generating a sitemap of a website built with Hakyll</title>
    <link href="https://futtetennismo.me/posts/hakyll/2017-10-23-sitemap-hakyll.html" />
    <id>https://futtetennismo.me/posts/hakyll/2017-10-23-sitemap-hakyll.html</id>
    <published>2017-10-23T00:00:00Z</published>
    <updated>2017-10-23T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Adding <code>sitemap.xml</code> and <code>robots.txt</code> to a website built with Hakyll is not explicitly documented but it ended up being quite easy with the help of some DuckDuckGo-fu. <!--more--> A quick <a href="https://duckduckgo.com/?q=hakyll+sitemap.xml">research</a> returns <a href="https://www.rohanjain.in/hakyll-sitemap/">this post</a>. With a few amendments the solution proposed in the post works like a charm, here’s the revised version I use for my website:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">  create [<span class="st">&quot;sitemap.xml&quot;</span>] <span class="fu">$</span> <span class="kw">do</span>
    route idRoute
    compile <span class="fu">$</span> <span class="kw">do</span>
      posts <span class="ot">&lt;-</span> recentFirst <span class="fu">=&lt;&lt;</span> loadAll <span class="st">&quot;posts/**&quot;</span>
      pages <span class="ot">&lt;-</span> loadAll <span class="st">&quot;pages/*&quot;</span>
      <span class="kw">let</span>
        crawlPages <span class="fu">=</span>
          sitemapPages pages <span class="fu">++</span> posts
        sitemapCtx <span class="fu">=</span>
          mconcat [ listField <span class="st">&quot;entries&quot;</span> defaultContext (return crawlPages)
                  , defaultContext
                  ]
      makeItem <span class="st">&quot;&quot;</span>
        <span class="fu">&gt;&gt;=</span> loadAndApplyTemplate <span class="st">&quot;templates/sitemap.xml&quot;</span> sitemapCtx
        <span class="fu">&gt;&gt;=</span> relativizeUrls

  match (fromList [<span class="st">&quot;robots.txt&quot;</span>, <span class="st">&quot;CNAME&quot;</span>]) <span class="fu">$</span> <span class="kw">do</span>
    route idRoute
    compile <span class="fu">$</span> getResourceBody <span class="fu">&gt;&gt;=</span> relativizeUrls</code></pre></div>
<p>Notice how the <code>robots.txt</code> and <code>CNAME</code> files - the latter is needed by my domain name registrar - are simply copied since there’s no need to apply any processing to them.</p>]]></summary>
</entry>
<entry>
    <title>Deploying a Hakyll website using Github Pages and CircleCI 2.0</title>
    <link href="https://futtetennismo.me/posts/hakyll/2017-10-22-deploying-to-github-pages-using-circleci-2.0.html" />
    <id>https://futtetennismo.me/posts/hakyll/2017-10-22-deploying-to-github-pages-using-circleci-2.0.html</id>
    <published>2017-10-22T00:00:00Z</published>
    <updated>2017-10-22T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>One of the last things left to figure out when I was about to lauch this website was finding a workflow to nicely deploy it. I was using Jekyll + Github Pages for my old website and it was working well enough for me so I didn’t want to radically change the way I was doing things. On the other hand I didn’t update my old website in a while and I am new to Hakyll so I had to figure out if I could keep a similar workflow. I ended up spending a few hours figuring out a solution I was happy with and the following is a description of my present workflow and how I got to it. <!--more--> On the Hakyll website there are a <a href="https://www.stackbuilders.com/news/dr-hakyll-create-a-github-page-with-hakyll-and-circleci">few</a> <a href="http://kyle.marek-spartz.org/posts/2013-12-09-widely-and-hakyll.html">blog</a> <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">posts</a> on the topic. I initially blindly followed the <a href="http://kyle.marek-spartz.org/posts/2013-12-09-widely-and-hakyll.html">one</a> using <a href="https://circleci.com/">CircleCI</a> but I wished there was a simpler solution not involving git submodules; on the other hand the <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">other</a> was simple but focused developing on a local machine. I wished I could find a solution that combined both and I ended up finding it thanks to the fact that CircleCI rolled out their <a href="https://circleci.com/docs/2.0/">2.0 release</a>.</p>
<h3 id="setting-up-circleci-2.0">Setting up CircleCI 2.0</h3>
<p>Configuration files in CircleCI 2.0 are quite different from 1.0 so I couldn’t reuse much of the code in this <a href="https://www.stackbuilders.com/news/dr-hakyll-create-a-github-page-with-hakyll-and-circleci">post</a> but I found the docs quite good and the whole configuration options quite intuitive. CircleCI 2.0 adds great support for Docker, so I ended up creating a custom <a href="https://hub.docker.com/r/futtetennista/hakyll/">docker image</a> for my website after trying the <a href="https://hub.docker.com/_/haskell/">official Haskell image</a> and stumbling upon two main issues:</p>
<ol style="list-style-type: decimal">
<li><code>ssh</code> isn’t installed by default: this is a problem when checking out or pushing to a remote git repository (checkout actually works somehow thanks to some tricks CircleCI does but it logs a warning in its console)</li>
<li><code>make</code> isn’t installed by default: my website uses <a href="https://github.com/meoblast001/hakyll-sass/">hakyll-sass</a> that has a C++ dependency - <code>libsass</code> - that needs to be built</li>
</ol>
<p>After that the project was building but it was compiling all dependecies. Building a site from scratch takes quite a bit - ~20 minutes on my local machine and ~12 minutes in CircleCI - so it’s critical to use CircleCI’s <a href="https://circleci.com/docs/2.0/caching/">caching</a> to speed things up. The <code>save_cache</code> and <code>restore_cache</code> job-level keys are the ones to configure in order to speed up the build, this is how the caching section looks for my project:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml">  <span class="kw">-</span> <span class="fu">restore_cache:</span>
      <span class="fu">key:</span><span class="at"> v1-stack-{{ checksum &quot;futtetennismo.cabal&quot; }}</span>
  ...
  <span class="kw">-</span> <span class="fu">save_cache:</span>
      <span class="fu">paths:</span>
        <span class="kw">-</span> ~/futtetennismo/.stack-work
        <span class="kw">-</span> /root/.stack/
      <span class="fu">key:</span><span class="at"> v1-stack-work-{{ checksum &quot;futtetennismo.cabal&quot; }}</span></code></pre></div>
<p>It’s very simple: just let CircleCI know that it should cache and how the cache should be named in order to be retrieved at a later time. The improvements on build time are dramatic: from ~20 minutes in case of build with no cache to ~2 minutes in the worst case (when a new cache archive needs to be created and uploaded) to ~30 seconds in the average case!</p>
<h5 id="tldr">TL;DR</h5>
<p>Here’s something to keep in mind when caching in CircleCI 2.0</p>
<blockquote>
<p>The cache for a specific key is immutable and cannot be changed once written.</p>
</blockquote>
<p>In early experiments the <code>save_cache</code> job-level key in my <code>config.yml</code> looked like this</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml">  <span class="kw">-</span> <span class="fu">save_cache:</span>
      <span class="fu">paths:</span>
        <span class="kw">-</span> ~/futtetennismo/.stack-work
      <span class="fu">key:</span><span class="at"> stack-work-{{ checksum &quot;futtetennismo.cabal&quot; }}</span></code></pre></div>
<p>but every new build was again taking a long time because the cache was mostly useless. Then I added <code>root/.stack</code> to the <code>paths</code> but still nothing, the cache was just a few under KB. At that point I noticed this tip in the docs:</p>
<blockquote>
<p>Tip: Given the immutability of caches, it might be helpful to start all your cache keys with a version prefix v1-… . That way you will be able to regenerate all your caches just by incrementing the version in this prefix.</p>
</blockquote>
<p>That meant that <code>save_cache</code> never overwrites an existing cache! I ended up building a new cache following that tip.</p>
<h5 id="ssh-keys">SSH keys</h5>
<p>The missing piece in the puzzle is now setting up ssh key in CircleCI to be able to checkout the project and push new versions of the website. I ended up creating a read/write deployment key for pushing to github and a checkout key for fetching from github. The latter is just a matter of a few clicks, the former involves some manual work but the docs by the Github folks are easy to follow.</p>
<p><strong>UPDATE</strong>: if a read/write deployment key is created and added to a project in CircleCI, there’s actually no need to also have a checkout key.</p>
<h6 id="bonus-goodness">Bonus goodness</h6>
<p>One feature that CircleCI provides (and which proved to be extremely handy when debugging some issues setting up ssh keys) is the ability to connect to a running container via ssh. Bravo to the CircleCI folks!</p>
<h3 id="workflow">Workflow</h3>
<p>The workflow I ended up adopting is a mix of <a href="http://kyle.marek-spartz.org/posts/2013-12-09-widely-and-hakyll.html">this</a> <a href="https://jaspervdj.be/hakyll/tutorials/github-pages-tutorial.html">two</a> tutorials. The <code>master</code> branch - which is the one deployed by Github Pages in case of a user page - contains all the static assets of the website like images, html, css etc. Another branch - that I arbitrarily named <code>source</code> - contains all source code and each time a new commit is pushed to that branch CircleCI will build a version of my website and will eventually push it to Github (if the build succeeds). For convenience, I also configured my build in such a way that CircleCI builds <em>only</em> that branch. Here’s a snippet of the <code>deploy</code> job-level key in the <code>config.yml</code>:</p>
<div class="sourceCode"><pre class="sourceCode yaml"><code class="sourceCode yaml"><span class="fu">version:</span><span class="at"> 2</span>
<span class="fu">jobs:</span>
  <span class="fu">build:</span>
    <span class="fu">working_directory:</span><span class="at"> ~/futtetennismo</span>
  <span class="fu">branches:</span>
    <span class="fu">only:</span>
      <span class="kw">-</span> source
  ...
  <span class="kw">-</span> <span class="fu">deploy:</span>
      <span class="fu">name:</span><span class="at"> Deploy master to Github Pages</span>
      <span class="fu">command:</span><span class="at"> |</span>
        git config --global user.email robots@circleci.com
        git config --global user.name CircleCI
        stack exec site rebuild
        git checkout master
        git pull --rebase
        <span class="co"># Overwrite existing files with new files</span>
        cp -a _site/. .
        <span class="co">#  Commit</span>
        git add --all
        git commit -m <span class="st">&quot;[`date &#39;+%F %T %Z&#39;`] New release&quot;</span>
        <span class="co"># Push</span>
        <span class="fu">git push origin master:</span><span class="at">master</span></code></pre></div>
<p>As a last little bonus, I wrote a simple <code>pre-push</code> hook to open my browser and follow the deployment:</p>
<pre><code>#!/usr/bin/env sh

if [ $(git rev-parse --abbrev-ref HEAD) == &#39;source&#39; ]
then
    open &quot;https://circleci.com/gh/futtetennista/futtetennista.github.com&quot;
fi</code></pre>
<h3 id="wrapping-up">Wrapping up</h3>
<p>I described a workflow to be able to deploy websites built with Hakyll in a fully automated fashion using Github Pages and CircleCI 2.0 and I pointed out some of the gotchas I learned in the process. The code is open source and can be found on <a href="https://github.com/futtetennista/futtetennista.github.com">Github</a>.</p>]]></summary>
</entry>
<entry>
    <title>Migrating from lazy IO to Conduit</title>
    <link href="https://futtetennismo.me/posts/haskell/2017-10-21-lazy-io-to-conduit.html" />
    <id>https://futtetennismo.me/posts/haskell/2017-10-21-lazy-io-to-conduit.html</id>
    <published>2017-10-21T00:00:00Z</published>
    <updated>2017-10-21T00:00:00Z</updated>
    <summary type="html"><![CDATA[
<p>Lazy IO is so tricky to get right and has some intrinsic limitations that the usual recommendation is to simply avoid it. On the other hand sometimes it’s not desirable (or even possible) to use strict IO, mostly for memory efficiency reasons. This is the kind of problems that streaming libraries like <a href="https://hackage.haskell.org/package/conduit">conduit</a> or <a href="https://hackage.haskell.org/package/pipes">pipes</a> are designed to solve. In this post I want to show how I refactored a piece of code that uses lazy IO to use the conduit library (for those not familiar with it, please read this <a href="https://haskell-lang.org/library/conduit">conduit tutorial</a> first). <!--more--> I enjoyed reading Real World Haskell and I am convinced that is still a must-read for people who want to learn and work proficiently with Haskell, but it’s true that a lot changed in these last few years and new libraries or best practices have been developed so some code could be updated. This post intends to be the first of a series of posts that will take a piece of code from the book and rewrites it using more modern idioms. This time the code is taken from chapter 28: it implements a URL checker that parses some command line arguments - a list of text files containing the urls to be checked and a number representing the amount of worker threads that will concurrently check those urls - creates a <code>Job</code> that extracts all the well-formed urls, a <code>Task</code> for each url that needs to be checked and puts it in a job queue that worker threads poll to get new urls to check. The program waits until all urls are checked and prints out some statistics about those URLs. Let’s start by having a look a the typess:</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Task</span> <span class="fu">=</span> <span class="dt">Done</span> <span class="fu">|</span> <span class="dt">Check</span> <span class="dt">URL</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">URL</span> <span class="fu">=</span> <span class="dt">Lazy.ByteString</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">JobState</span> <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">JobState</span> {<span class="ot"> linksSeen ::</span> <span class="dt">Set.Set</span> <span class="dt">URL</span>
<span class="ot">&gt;</span>            ,<span class="ot"> linksFound ::</span> <span class="fu">!</span><span class="dt">Int</span>
<span class="ot">&gt;</span>            ,<span class="ot"> linkQueue ::</span> <span class="dt">TChan</span> <span class="dt">Task</span>
<span class="ot">&gt;</span>            }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Job</span> a <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Job</span> {<span class="ot"> runJob ::</span> <span class="dt">StateT</span> <span class="dt">JobState</span> <span class="dt">IO</span> a }
<span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">JobState</span>, <span class="dt">MonadIO</span>)</code></pre></div>
<p>The <code>checkUrls</code> function glues together a few things: extracting the urls from the input file, filtering out duplicates, enqueueing the tasks in the job queue and updating the statistics</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; checkURLs ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Job</span> ()
<span class="ot">&gt;</span> checkURLs f <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   src <span class="ot">&lt;-</span> liftIO <span class="fu">$</span> Lazy.readFile f
<span class="ot">&gt;</span>   <span class="kw">let</span>
<span class="ot">&gt;</span>     urls <span class="fu">=</span> extractLinks src
<span class="ot">&gt;</span>   uniqueUrls <span class="ot">&lt;-</span> filterM seenURI urls
<span class="ot">&gt;</span>   mapM_ insertURI uniqueUrls
<span class="ot">&gt;</span>   enqueueTasks uniqueUrls
<span class="ot">&gt;</span>   updateStats (length urls)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; updateStats ::</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> <span class="dt">Job</span> ()
<span class="ot">&gt;</span> updateStats numUrls <span class="fu">=</span>
<span class="ot">&gt;</span>   modify <span class="fu">$</span> \s <span class="ot">-&gt;</span> s { linksFound <span class="fu">=</span> linksFound s <span class="fu">+</span> numUrls }
<span class="ot">&gt; seenURI ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">Job</span> <span class="dt">Bool</span>
<span class="ot">&gt;</span> seenURI url <span class="fu">=</span>
<span class="ot">&gt;</span>   (not <span class="fu">.</span> Set.member url) <span class="fu">&lt;$&gt;</span> gets linksSeen
<span class="ot">&gt; insertURI ::</span> <span class="dt">URL</span> <span class="ot">-&gt;</span> <span class="dt">Job</span> ()
<span class="ot">&gt;</span> insertURI url <span class="fu">=</span>
<span class="ot">&gt;</span>   modify <span class="fu">$</span> \s <span class="ot">-&gt;</span> s { linksSeen <span class="fu">=</span> Set.insert url (linksSeen s) }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; enqueueTasks ::</span> [<span class="dt">URL</span>] <span class="ot">-&gt;</span> <span class="dt">Job</span> ()
<span class="ot">&gt;</span> enqueueTasks urls <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   q <span class="ot">&lt;-</span> gets linkQueue
<span class="ot">&gt;</span>   liftIO <span class="fu">.</span> atomically <span class="fu">$</span> mapM_ (writeTChan q <span class="fu">.</span> <span class="dt">Check</span>) urls</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; extractLinks ::</span> <span class="dt">Lazy.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">URL</span>]
<span class="ot">&gt;</span> extractLinks <span class="fu">=</span>
<span class="ot">&gt;</span>   Lazy.lines <span class="co">-- filtering of invalid urls omitted</span></code></pre></div>
<p>For the version using conduits we’ll aim to remove everything that relies on lazy IO, using strict <code>ByteString</code>s and conduits. There is just one change needed in the types, namely re-defining the <code>URL</code> type alias</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">Task&#39;</span> <span class="fu">=</span> <span class="dt">Done&#39;</span> <span class="fu">|</span> <span class="dt">Check&#39;</span> <span class="dt">URL&#39;</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">type</span> <span class="dt">URL&#39;</span> <span class="fu">=</span> <span class="dt">Strict.ByteString</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">data</span> <span class="dt">JobState&#39;</span> <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">JobState&#39;</span> {<span class="ot"> linksSeen&#39; ::</span> <span class="dt">Set.Set</span> <span class="dt">URL&#39;</span>
<span class="ot">&gt;</span>             ,<span class="ot"> linksFound&#39; ::</span> <span class="fu">!</span><span class="dt">Int</span>
<span class="ot">&gt;</span>             ,<span class="ot"> linkQueue&#39; ::</span> <span class="dt">TChan</span> <span class="dt">Task&#39;</span>
<span class="ot">&gt;</span>             }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;</span> <span class="kw">newtype</span> <span class="dt">Job&#39;</span> a <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Job&#39;</span> {<span class="ot"> runJob&#39; ::</span> <span class="dt">StateT</span> <span class="dt">JobState&#39;</span> <span class="dt">IO</span> a }
<span class="ot">&gt;</span>   <span class="kw">deriving</span> (<span class="dt">Functor</span>, <span class="dt">Applicative</span>, <span class="dt">Monad</span>, <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span>, <span class="dt">MonadIO</span>)</code></pre></div>
<p>The <code>checkURL</code> function is - as you might expect - quite different given how the conduit library is designed. In conduit “everything is driven by the downstream” so I found it useful to ask myself this question: what output does the function need to produce? In this case <code>checkURLs</code> needs to do essentially two things: 1) creating and enqueuing <code>Task</code>s to be picked up by worker threads and 2) updating some statistics in <code>JobState</code>. The first shift in thinking is that I found necessary is to think only in terms of pipelines and leave out <code>let</code> bindings. This poses a challenge though: the extracted urls are needed for both 1) and 2) but once they go through 1) urls are transformed into a job and that’s not what 2) expects as an input. I found two to three possible solutions to the problem: changing the signatures of the helper functions so that the input urls are always returned wrapped in a monad (this reminded me of the “fluent” style used for example for builders in languages like Java) to allow the stream to “keep flowing downstream”, using zipped conduits and a mix of the two. The <code>ZipCounduit</code> is a handy type that makes it possible to split the stream into two identical streams that can be consumed by two different downstream conduits: this way both 1) and 2) can get the input data they expect. I’m not entirely sure what’s more idiomatic or elegant or - more importantly - clear though.</p>
<p>First let’s start with the helper functions (I’ll just write type signatures for their variations in the following snippets), their implementation is the same but the type signature of most of them is slightly different - more on this below</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; extractLinks&#39; ::</span> <span class="dt">Strict.ByteString</span> <span class="ot">-&gt;</span> [<span class="dt">URL&#39;</span>]
<span class="ot">&gt;</span> extractLinks&#39; <span class="fu">=</span>
<span class="ot">&gt;</span>   Strict.lines <span class="co">-- filtering of invalid urls omitted</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; updateStats&#39; ::</span> <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m ()
<span class="ot">&gt;</span> updateStats&#39; numUrls <span class="fu">=</span>
<span class="ot">&gt;</span>   modify <span class="fu">$</span> \s <span class="ot">-&gt;</span> s { linksFound&#39; <span class="fu">=</span> linksFound&#39; s <span class="fu">+</span> numUrls }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; seenURI&#39; ::</span> <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m <span class="ot">=&gt;</span> <span class="dt">URL&#39;</span> <span class="ot">-&gt;</span> m <span class="dt">Bool</span>
<span class="ot">&gt;</span> seenURI&#39; url <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   (not <span class="fu">.</span> Set.member url) <span class="fu">&lt;$&gt;</span> gets linksSeen&#39;</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; insertURI&#39; ::</span> <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m <span class="ot">=&gt;</span> <span class="dt">URL&#39;</span> <span class="ot">-&gt;</span> m ()
<span class="ot">&gt;</span> insertURI&#39; url <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   modify <span class="fu">$</span> \s <span class="ot">-&gt;</span> s { linksSeen&#39; <span class="fu">=</span> Set.insert url (linksSeen&#39; s) }</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; enqueueTasks&#39; ::</span> (<span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m, <span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> [<span class="dt">URL&#39;</span>] <span class="ot">-&gt;</span> m ()
<span class="ot">&gt;</span> enqueueTasks&#39; urls <span class="fu">=</span> <span class="kw">do</span>
<span class="ot">&gt;</span>   queue <span class="ot">&lt;-</span> gets linkQueue&#39;
<span class="ot">&gt;</span>   liftIO <span class="fu">.</span> atomically <span class="fu">$</span> mapM_ (writeTChan queue <span class="fu">.</span> <span class="dt">Check&#39;</span>) urls</code></pre></div>
<p>The the first solution - no <code>ZipConduits</code>s involved - looks like this</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; checkURLs&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Job&#39;</span> ()
<span class="ot">&gt;</span> checkURLs&#39; fp <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Job&#39;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>     runConduitRes <span class="fu">$</span> sourceFileBS fp
<span class="ot">&gt;</span>       <span class="fu">.|</span> mapC extractLinks&#39;
<span class="ot">&gt;</span>       <span class="fu">.|</span> filterMCE seenURI&#39;
<span class="ot">&gt;</span>       <span class="fu">.|</span> mapMCE insertURI&#39;
<span class="ot">&gt;</span>       <span class="fu">.|</span> mapMC enqueueTasks&#39;
<span class="ot">&gt;</span>       <span class="fu">.|</span> mapM_C (updateStats&#39; <span class="fu">.</span> length)
<span class="ot">&gt;</span> 
<span class="ot">&gt; updateStats&#39; ::</span> <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> m ()
<span class="ot">&gt; insertURI&#39; ::</span> <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m <span class="ot">=&gt;</span> <span class="dt">URL&#39;</span> <span class="ot">-&gt;</span> <span class="dt">URL&#39;</span> ()
<span class="ot">&gt; enqueueTasks&#39; ::</span> (<span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m, <span class="dt">MonadIO</span> m) <span class="ot">=&gt;</span> [<span class="dt">URL&#39;</span>] <span class="ot">-&gt;</span> m [<span class="dt">URL&#39;</span>]</code></pre></div>
<p>The second solution uses two <code>ZipConduit</code>s</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; checkURLs&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Job&#39;</span> ()
<span class="ot">&gt;</span> checkURLs&#39; fp <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Job&#39;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>     runConduitRes <span class="fu">$</span> sourceFileBS fp
<span class="ot">&gt;</span>       <span class="fu">.|</span> mapC extractLinks&#39;
<span class="ot">&gt;</span>       <span class="fu">.|</span> setupJob
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     setupJob ::</span> <span class="dt">Consumer</span> [<span class="dt">URL&#39;</span>] (<span class="dt">ResourceT</span> (<span class="dt">StateT</span> <span class="dt">JobState&#39;</span> <span class="dt">IO</span>)) ()
<span class="ot">&gt;</span>     setupJob <span class="fu">=</span>
<span class="ot">&gt;</span>       getZipConduit <span class="fu">$</span>
<span class="ot">&gt;</span>         <span class="dt">ZipConduit</span> insertAndEnqueue
<span class="ot">&gt;</span>         <span class="fu">*&gt;</span> <span class="dt">ZipConduit</span> (mapM_C (updateStats&#39; <span class="fu">.</span> length))</code></pre></div>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt;     insertAndEnqueue ::</span> <span class="dt">Consumer</span> [<span class="dt">URL&#39;</span>] (<span class="dt">ResourceT</span> (<span class="dt">StateT</span> <span class="dt">JobState&#39;</span> <span class="dt">IO</span>)) ()
<span class="ot">&gt;</span>     insertAndEnqueue <span class="fu">=</span>
<span class="ot">&gt;</span>       filterMCE seenURI&#39; <span class="fu">.|</span> (getZipConduit <span class="fu">$</span>
<span class="ot">&gt;</span>                                <span class="dt">ZipConduit</span> (mapM_CE insertURI&#39;)
<span class="ot">&gt;</span>                                <span class="fu">&lt;*</span> <span class="dt">ZipConduit</span> (mapM_C enqueueTasks&#39;))</code></pre></div>
<p>Finally the third solution uses one <code>ZipConduits</code>s and modifies <code>insertURI'</code> to return a <code>URL'</code> so that the stream can “keep flowing down”</p>
<div class="sourceCode"><pre class="sourceCode literate literatehaskell"><code class="sourceCode literatehaskell"><span class="ot">&gt; checkURLs&#39; ::</span> FilePath <span class="ot">-&gt;</span> <span class="dt">Job&#39;</span> ()
<span class="ot">&gt;</span> checkURLs&#39; fp <span class="fu">=</span>
<span class="ot">&gt;</span>   <span class="dt">Job&#39;</span> <span class="fu">$</span>
<span class="ot">&gt;</span>     runConduitRes <span class="fu">$</span> sourceFileBS fp
<span class="ot">&gt;</span>       <span class="fu">.|</span> mapC extractLinks&#39;
<span class="ot">&gt;</span>       <span class="fu">.|</span> setupJob
<span class="ot">&gt;</span>   <span class="kw">where</span>
<span class="ot">&gt;     setupJob ::</span> <span class="dt">Consumer</span> [<span class="dt">URL&#39;</span>] (<span class="dt">ResourceT</span> (<span class="dt">StateT</span> <span class="dt">JobState&#39;</span> <span class="dt">IO</span>)) ()
<span class="ot">&gt;</span>     setupJob <span class="fu">=</span>
<span class="ot">&gt;</span>       getZipConduit <span class="fu">$</span>
<span class="ot">&gt;</span>         <span class="dt">ZipConduit</span> (filterMCE seenURI&#39;
<span class="ot">&gt;</span>                       <span class="fu">.|</span> mapM_CE insertURI&#39;
<span class="ot">&gt;</span>                       <span class="fu">.|</span> mapM_C enqueueTasks&#39;)
<span class="ot">&gt;</span>         <span class="fu">*&gt;</span> <span class="dt">ZipConduit</span> (mapM_C (updateStats&#39; <span class="fu">.</span> length))
<span class="ot">&gt;</span> 
<span class="ot">&gt; insertURI&#39; ::</span> <span class="dt">MonadState</span> <span class="dt">JobState&#39;</span> m <span class="ot">=&gt;</span> <span class="dt">URL&#39;</span> <span class="ot">-&gt;</span> <span class="dt">URL&#39;</span> ()</code></pre></div>
<p>The type signatures of most of this helper functions is slightly different - namely it’s more general: why is this needed? If the type signature of <code>updateStats'</code> was <code>updateStats' :: Int -&gt; Job' ()</code> the compiler would complain with the following error: <code>Couldn't match type ‘Job’ with ‘ResourceT (StateT JobState IO)’</code>. It took me a bit to fix this and make the compiler happy, again I’m not entirely sure that’s the best way of solving the issue but it works. My first try was - following compiler errors - to make <code>Job</code> an instance of <code>MonadThrow</code>, <code>MonadBase</code> but I stopped before implementing an instance for <code>MonadBaseControl</code> since it couldn’t be derived atomatically and I was under the impression that it was too much of a hassle giving that <code>Job'</code> is just a <code>newtype</code> wrapper for <code>StateT</code>, which is already an instance of <code>MonadBaseControl</code>. If I could take the <code>StateT</code> transformer and then just wrap it in a <code>Job'</code> constructor then that would do the job…and that’s made possible by modifying the type signatures of those functions. Actually if I had just type inference do its job it’d have inferred the types correctly, but I’m used to write type signatures first and then write an implementation and that bit me this time.</p>
<p>To check that all this works as expected, let’s try it out in GHCI</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ queue <span class="ot">&lt;- newTChanIO ::</span> <span class="dt">IO</span> <span class="dt">TChan</span> <span class="dt">Task&#39;</span>
<span class="ot">queue ::</span> <span class="dt">TChan</span> <span class="dt">Task&#39;</span>
ƛ <span class="kw">let</span> job <span class="fu">=</span> checkURLs&#39; <span class="st">&quot;urls.txt&quot;</span> <span class="co">-- urls.txt contains a list of urls</span>
<span class="ot">job ::</span> <span class="dt">Job&#39;</span> ()
ƛ st <span class="ot">&lt;-</span> execStateT (runJob&#39; job) (<span class="dt">JobState&#39;</span> Set.empty <span class="dv">0</span> queue)
<span class="ot">st ::</span> <span class="dt">JobState&#39;</span>
ƛ <span class="fu">:</span>m <span class="fu">+</span><span class="dt">Control.Exception</span>
ƛ assert (linksFound&#39; st <span class="fu">&gt;</span> <span class="dv">0</span>) (<span class="st">&quot;Found &quot;</span> <span class="fu">++</span> linksFound&#39; st <span class="fu">++</span> <span class="st">&quot; links&quot;</span>)
<span class="st">&quot;Found 2 links&quot;</span>
ƛ assert (linksSeen&#39; st <span class="fu">&gt;</span> <span class="dv">0</span>) (<span class="st">&quot;Seen &quot;</span> <span class="fu">++</span> linksSeen&#39; st <span class="fu">++</span> <span class="st">&quot; links&quot;</span>)
<span class="st">&quot;Seen 3 links&quot;</span>
ƛ emptyQueue <span class="ot">&lt;-</span> atomically <span class="fu">$</span> isEmptyTChan queue
<span class="ot">emptyQueue ::</span> <span class="dt">Bool</span>
ƛ assert (not emptyQueue) <span class="st">&quot;Queue not empty&quot;</span>
<span class="st">&quot;Queue not empty&quot;</span></code></pre></div>
<h2 id="wrapping-up">Wrapping up</h2>
<p>In this post I shown how to refactor a piece of code using lazy IO to use the conduit library to write a little program that reads data from files efficiently when it comes to memory usage, illustrated some of the challenges I faced while doing that and explained some of possible solutions I found.</p>]]></summary>
</entry>
<entry>
    <title>Being lazy with consciousness</title>
    <link href="https://futtetennismo.me/posts/haskell/2017-10-14-strictness.html" />
    <id>https://futtetennismo.me/posts/haskell/2017-10-14-strictness.html</id>
    <published>2017-10-14T00:00:00Z</published>
    <updated>2017-10-14T00:00:00Z</updated>
    <summary type="html"><![CDATA[<p>Lazy evaluation sometimes makes it trickier to really understand how a piece of code for folks used to languages with strict semantics (as I am). Sometimes introducing strictness is necessary to avoid space leaks and to make memory allocations more predictable in certain parts of our code. The usual suggestion is to “carefully sprinkle strict evaluation” in our code; one of the classic examples of memory leak is using <code>foldl</code> to sum a list of ints, with the result that instead of returning a result using constant space, it ends up taking an outrageous amount of memory before returning a result because thunks pile up (this behaviour is known as space leak). Most of the times I personally find it tricky to add strictness to a piece of Haskell code, so I’d like to share my latest experience doing that.</p>
<p>We’ll be using the Bloom filter implemented in chapter 26 of Real World Haskell as an example, the version contained in the book creates the filter lazily: our goal will be to create a strict version of that particular piece of code. <!--more--> In a nutshell, a <a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a> is a probabilistic data structure that consists of several hash functions and a bit array whose API allows only insertion and membership querying. The latter API might return false positives with an expected error rate decided when the filter is instantiated. Here’s a function that builds a Bloom filter lazily:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- file: BloomFilter/BloomFilter.hs</span>

<span class="kw">import </span><span class="dt">BloomFilter.Immutable</span> <span class="kw">as</span> <span class="dt">B</span> (<span class="dt">IBloom</span>, fromList)
<span class="kw">import </span><span class="dt">BloomFilter.Hash</span> (<span class="dt">Hashable</span>, doubleHash)
<span class="kw">import </span><span class="dt">Data.List</span> (genericLength)
<span class="kw">import </span><span class="dt">Data.Either</span> (either)

<span class="ot">mkFromList ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> <span class="dt">Int</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">B.IBloom</span> a)
mkFromList errRate xs <span class="fu">=</span>
  either <span class="dt">Left</span> (<span class="dt">Right</span> <span class="fu">.</span> mkBFilt) <span class="fu">$</span> suggestSizing (genericLength xs) errRate
  <span class="kw">where</span>
    mkBFilt (bits, numHashes) <span class="fu">=</span>
      B.fromList (doubleHash numHashes) bits xs</code></pre></div>
<p>The function <code>suggestSizing</code> provides the optimal size of the underlying array and the number of hashes to generate given the length of the input list and the desired rate of false positives, but it’s not important for the topic of this article. Let’s try this code out in GHCI:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="fu">:</span>set <span class="fu">+</span>s <span class="co">-- to print timing/memory stats after each evaluation</span>
ƛ <span class="fu">:</span>load <span class="dt">BloomFilter.BloomFilter</span>
ƛ <span class="kw">let</span> ebf <span class="fu">=</span> mkFromList <span class="fl">0.01</span> ([<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span><span class="fu">^</span><span class="dv">6</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])
<span class="ot">ebf ::</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">B.IBloom</span> <span class="dt">Int</span>)
(<span class="fl">0.01</span> secs, <span class="dv">4658656</span> bytes)</code></pre></div>
<p>The fact that <code>ebf</code> has not been fully evaluated should be clear since the evaluation took almost no time, but let’s ask GHCI for help:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="fu">:</span>print ebf <span class="co">-- prints a value without forcing its computation</span>
ebf <span class="fu">=</span> (<span class="ot">_t2::</span><span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">B.IBloom</span> <span class="dt">Int</span>))</code></pre></div>
<p>GHCI is telling us that <code>ebf</code> is a thunk <code>_ts</code> of type <code>Either String (B.IBloom Int)</code>. If we’re still not convinced that <code>ebf</code> is not evaluated we can ask it if an element is contained in the Bloom filter:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ either (const <span class="dt">False</span>) (<span class="dv">1</span> <span class="ot">`B.elem`</span>) ebf
<span class="dt">True</span>
<span class="ot">it ::</span> <span class="dt">Bool</span>
(<span class="fl">19.44</span> secs, <span class="dv">13818404512</span> bytes)
ƛ either (const <span class="dt">False</span>) (<span class="dv">11</span> <span class="ot">`B.elem`</span>) ebf
<span class="dt">True</span>
<span class="ot">it ::</span> <span class="dt">Bool</span>
(<span class="fl">0.01</span> secs, <span class="dv">3118248</span> bytes)</code></pre></div>
<p>From the timing/memory information should be pretty clear now that the evaluation was forced when we explicitly asked for a membership test. That expected given Haskell’s non-strict semantic. If we ask GHCI to give us information about <code>ebf</code> we can see that now it gives us a different answer:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="fu">:</span>print ebf
ebf <span class="fu">=</span> <span class="dt">Right</span>
        (<span class="dt">B.IB</span>
           (<span class="ot">_t3::</span><span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Word32</span>])
           (<span class="dt">Data.Array.Base.UArray</span>
              (<span class="dt">GHC.Word.W32</span><span class="fu">#</span> <span class="dv">0</span>) (<span class="dt">GHC.Word.W32</span><span class="fu">#</span> <span class="dv">9592954</span>) <span class="dv">9592955</span>
              (<span class="ot">_t4::</span>ghc<span class="fu">-</span>prim<span class="fu">-</span><span class="fl">0.5</span><span class="fu">.</span><span class="fl">0.0</span><span class="fu">:</span><span class="dt">GHC.Prim.ByteArray</span><span class="fu">#</span>)))</code></pre></div>
<p>Let’s not focus on the types - again not important - GHCI is telling us the value of <code>ebf</code> after evaluation. We’d like to force this evaluation <em>before</em> the first time the Bloom filter is used, namely when it is created.</p>
<h4 id="beware-ghci">Beware GHCI</h4>
<p>In GHCI we <strong>always</strong> need to explicitly specify type annotations for bindings that need to be forced, otherwise the interpreter will infer the most general type and won’t force the evaluation of the term. This is related to <a href="https://wiki.haskell.org/Monomorphism_restriction">“the dreaded monomorphism restriction”</a>.</p>
<h2 id="tools-of-the-job">Tools of the job</h2>
<p>There are various ways of forcing evaluation in Haskell, the main ones are: <code>seq</code>, <code>deepseq</code>, <code>rnf</code> (the last two can be found in the <code>Control.DeepSeq</code> module and require the argument to be an instance of the <code>NFData</code> type class) or the handy <code>BangPatterns</code> extension, which is syntactic sugar for <code>seq</code>. As a first try, let’s force the evaluation of <code>ebf</code> using bang patters and see what happens:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="fu">:</span>set <span class="fu">-</span><span class="dt">XBangPatterns</span>
ƛ <span class="kw">let</span> <span class="fu">!</span>ebf&#39; <span class="fu">=</span> mkFromList <span class="fl">0.01</span> ([<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span><span class="fu">^</span><span class="dv">6</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])
<span class="ot">ebf&#39; ::</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">B.IBloom</span> <span class="dt">Int</span>)
(<span class="fl">0.34</span> secs, <span class="dv">197720920</span> bytes)
ƛ <span class="fu">:</span>print ebf&#39;
ebf&#39; <span class="fu">=</span> <span class="dt">Right</span> (<span class="ot">_t5::</span><span class="dt">B.IBloom</span> <span class="dt">Int</span>)</code></pre></div>
<p>That did something, specifically it evaluated <code>ebf'</code> a bit so that now we already know that the construction of the Bloom filter succeeded but did we manage to instantiate it? By carefully reading the output of GHCI it should be clear that we’re not quite there yet but let’s again double check:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ either (const <span class="dt">False</span>) (<span class="dv">11</span> <span class="ot">`B.elem`</span>) ebf&#39;
<span class="dt">True</span>
<span class="ot">it ::</span> <span class="dt">Bool</span>
(<span class="fl">19.02</span> secs, <span class="dv">13624548640</span> bytes)</code></pre></div>
<p>The membership test took still 19 seconds, as we expected. So what’s happening here? Now it’s probably a good point to introduce some terminology that will help us out understanding what’s happening and how to go forward.</p>
<h2 id="nf-and-whnf">NF and WHNF</h2>
<p>A reducible expression (or redex) is an expression that can be evaluated until a value is obtained, i.e. <code>let x = 1 + 6</code> is a redex since it can be evaluated to obtain <code>let x = 5</code>. Let’s again double check it in GHCI:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="kw">let</span> x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>
<span class="ot">x ::</span> <span class="dt">Int</span>
ƛ <span class="fu">:</span>print x
x <span class="fu">=</span> (<span class="ot">_t6::</span><span class="dt">Int</span>)
ƛ <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span>
<span class="ot">x ::</span> <span class="dt">Int</span>
ƛ <span class="fu">:</span>print x
x <span class="fu">=</span> <span class="dv">6</span></code></pre></div>
<p>At this point <code>x</code> cannot be futher evaluated and is said to be in normal (or canonical) form. Now what about an expression like <code>Right (1 + 5)</code>? It should be clear that it’s not in normal form so can we just force evaluation by adding a bang pattern? Let’s see if that works:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="dt">Right</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Either</span> a <span class="dt">Int</span>
<span class="ot">x ::</span> <span class="dt">Either</span> a <span class="dt">Int</span>
ƛ <span class="fu">:</span>print x
x <span class="fu">=</span> <span class="dt">Right</span> (<span class="ot">_t8::</span><span class="dt">Int</span>)</code></pre></div>
<p>What’s happening here?! It turns out that an expression in Haskell can be in other form called weak head normal form when it’s not a redex itself and further evaluation of its sub-expressions cannot make it a redex. <code>Right (1 + 5)</code> isn’t a redex (<code>Right</code> is a constructor for the <code>Either</code> type) and it cannot be made one if the sub-expression <code>1 + 5</code> is evaluated. Does that mean we have to unwrap the sub-expression in order for it to be evaluated? Not necessarily. We have a few options, namely forcing the evaluation of the sub-expression before we wrap it:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="kw">let</span> <span class="fu">!</span>y <span class="fu">=</span> <span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span><span class="ot"> ::</span> <span class="dt">Int</span> <span class="kw">in</span> <span class="dt">Right</span> y
<span class="ot">x ::</span> <span class="dt">Either</span> a <span class="dt">Int</span>
ƛ <span class="fu">:</span>print x
x <span class="fu">=</span> <span class="dt">Right</span> <span class="dv">6</span></code></pre></div>
<p>or levaraging some of the functions in the <code>Control.DeepSeq</code> module:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="kw">let</span> x <span class="fu">=</span> <span class="dt">Right</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Either</span> a <span class="dt">Int</span> <span class="kw">in</span> x <span class="ot">`deepseq`</span> x
<span class="ot">x ::</span> <span class="dt">Either</span> a <span class="dt">Int</span>
ƛ <span class="fu">:</span>print x
x <span class="fu">=</span> <span class="dt">Right</span> <span class="dv">6</span>
ƛ <span class="kw">let</span> <span class="fu">!</span>x <span class="fu">=</span> <span class="dt">Right</span> (<span class="dv">1</span> <span class="fu">+</span> <span class="dv">5</span>)<span class="ot"> ::</span> <span class="dt">Either</span> a <span class="dt">Int</span>
<span class="ot">x ::</span> <span class="dt">Either</span> a <span class="dt">Int</span>
ƛ rnf x
()
<span class="ot">it ::</span> ()
ƛ <span class="fu">:</span>print x
x <span class="fu">=</span> <span class="dt">Right</span> <span class="dv">6</span></code></pre></div>
<p><code>deepseq</code> is like <code>seq</code> on steroids, it reduces an expression and all its sub-expressions to normal form (<code>rnf</code> which stays for “reduce to normal form” does exactly the same). Again keep in mind is that in order to use these two functions the argument must be an instance of <code>NFData</code> (Normal Form Data).</p>
<p>A more in depth explanation and a bunch of very informative links and more examples can be found in Stephen Diehl’s <a href="http://dev.stephendiehl.com/hask/#laziness">What I wish I knew when learning Haskell</a></p>
<h2 id="taking-control">Taking control</h2>
<p>Now that we’are aware of all this, let’s create a strict version of our <code>mkFromList</code> function and let’s call it <code>mkFromList'</code> (using the convention other functions like <code>foldr'</code> use). The first function we need to change is <code>(Right . mkBFilt)</code>: this is equivalent to <code>\x -&gt; Right (mkBFilt x)</code> (using <a href="https://en.wikipedia.org/wiki/Lambda_calculus#.CE.B7-conversion">eta-expansion</a>) and to <code>\pair -&gt; let bfilt = mkBFilt pair in Right bfilt</code> if we massage the lambda a bit. Here <code>bfilt</code> needs to be evaluated so again the easiest thing to do is to add a bang pattern: <code>\pair -&gt; let !bfilt = mkBFilt pair in Right bfilt</code>. A quick note for about point-free style: adding strictness is a bummer in that respect. Let’s have a look at the following code</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- file: BloomFilter/BloomFilter.hs</span>

mkFromList&#39; errRate xs <span class="fu">=</span>
  either <span class="dt">Left</span> (<span class="dt">Right</span> <span class="fu">.</span> mkFilt&#39;) <span class="fu">$</span> suggestSizing (genericLength xs) errRate
  <span class="kw">where</span>
    mkBFilt&#39; (bits, numHashes) <span class="fu">=</span>
      <span class="kw">let</span> <span class="fu">!</span>bfilt <span class="fu">=</span>  B.fromList (doubleHash numHashes) bits xsin bfilt</code></pre></div>
<p>By eta-expanding <code>(Right . mkFilt')</code> we obtain <code>\pair -&gt; Right (mkFilt' pair)</code> that is a function that will be evaluated lazily. Are we done yet? Almost. Let’s have a look at the type of <code>ebf'</code> again: <code>Either String (B.IBloom Int)</code>. What’s <code>IBloom</code> (the ‘I’ stays for “immutable”)? Here’s how it’s defined:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- file: BloomFilter/Internals.hs</span>

<span class="kw">data</span> <span class="dt">IBloom</span> <span class="fu">=</span>
  <span class="dt">IB</span> {<span class="ot"> hash  ::</span> (a <span class="ot">-&gt;</span> [<span class="dt">Word32</span>])
     ,<span class="ot"> array ::</span> <span class="dt">UArray</span> <span class="dt">Word32</span> <span class="dt">Bool</span>
     }</code></pre></div>
<p>This closely reflects the definition of a Bloom filter, we have a function that returns a list of hashes for a given value and an array of bits. Keeping in mind that a constructor is also a function, we might notice that there is still something we need to force evaluation upon: the <code>array</code> field. In order to do this let’s write a strict version of <code>mkBFilt</code>, this time using <code>seq</code> for a change:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- file: BloomFilter/BloomFilter.hs</span>

mkBFilt&#39; (bits, numHashes) <span class="fu">=</span>
  <span class="kw">let</span> bfilt <span class="fu">=</span> B.fromList (doubleHash numHashes) bits xs
  <span class="kw">in</span> array bfilt <span class="ot">`seq`</span> bfilt</code></pre></div>
<p>Equivalently, we could have pattern-matched on <code>bfilt</code> and used a bang pattern on its <code>array</code> field. The final version of our <code>mkFromList'</code> function looks something like this:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell"><span class="co">-- file: BloomFilter/BloomFilter.hs</span>

<span class="ot">mkFromList&#39; ::</span> <span class="dt">Hashable</span> a <span class="ot">=&gt;</span> <span class="dt">ErrorRate</span> <span class="ot">-&gt;</span> [a] <span class="ot">-&gt;</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">B.IBloom</span> a)
mkFromList&#39; errRate xs <span class="fu">=</span>
  either <span class="dt">Left</span> rightBFilt&#39; <span class="fu">$</span> suggestSizing (genericLength xs) errRate
  <span class="kw">where</span>
    rightBFilt&#39; x <span class="fu">=</span> <span class="kw">let</span> <span class="fu">!</span>bfilt <span class="fu">=</span> mkBFilt&#39; x <span class="kw">in</span> <span class="dt">Right</span> bfilt

    mkBFilt&#39; (bits, numHashes) <span class="fu">=</span>
      <span class="kw">let</span> bfilt <span class="fu">=</span> B.fromList (doubleHash numHashes) bits xs
      <span class="kw">in</span> array bfilt <span class="ot">`seq`</span> bfilt</code></pre></div>
<p>Let’s test it in GHCI:</p>
<div class="sourceCode"><pre class="sourceCode haskell"><code class="sourceCode haskell">ƛ <span class="kw">let</span> <span class="fu">!</span>ebf&#39;&#39; <span class="fu">=</span> mkFromList&#39; <span class="fl">0.01</span> ([<span class="dv">1</span><span class="fu">..</span><span class="dv">10</span><span class="fu">^</span><span class="dv">6</span>]<span class="ot"> ::</span> [<span class="dt">Int</span>])
<span class="ot">ebf&#39;&#39; ::</span> <span class="dt">Either</span> <span class="dt">String</span> (<span class="dt">B.IBloom</span> <span class="dt">Int</span>)
(<span class="fl">19.29</span> secs, <span class="dv">13819004104</span> bytes)
ƛ <span class="fu">:</span>print ebf&#39;&#39;
ebf&#39;&#39; <span class="fu">=</span> <span class="dt">Right</span>
         (<span class="dt">B.IB</span>
            (<span class="ot">_t1::</span><span class="dt">Int</span> <span class="ot">-&gt;</span> [<span class="dt">Word32</span>])
            (<span class="dt">Data.Array.Base.UArray</span>
               (<span class="dt">GHC.Word.W32</span><span class="fu">#</span> <span class="dv">0</span>) (<span class="dt">GHC.Word.W32</span><span class="fu">#</span> <span class="dv">9592954</span>) <span class="dv">9592955</span>
               (<span class="ot">_t2::</span>ghc<span class="fu">-</span>prim<span class="fu">-</span><span class="fl">0.5</span><span class="fu">.</span><span class="fl">0.0</span><span class="fu">:</span><span class="dt">GHC.Prim.ByteArray</span><span class="fu">#</span>)))</code></pre></div>
<p>And YES! We finally managed to fully evaluate our Bloom filter before its first use in our code.</p>
<h2 id="wrapping-up">Wrapping up</h2>
<ol style="list-style-type: decimal">
<li>There are multiple ways we can use to introduce strictness in Haskell code: <code>seq</code>, the <code>BangPatterns</code> extension or the functions in the <code>Control.DeepSeq</code> module</li>
<li>Using GHCI and leveraging the <code>:print</code> command and the <code>+s</code> flag can help us understanding how our code is evaluated while developing</li>
<li>Keep in mind the difference between NF and WHNF: if we cannot manage to force evaluation of an expression it’s because some sub-expression is still in WHNF</li>
<li>Carefully analyse our code to identify where strictness needs to be added</li>
</ol>
<h2 id="further-readings">Further readings</h2>
<ul>
<li><a href="https://www.fpcomplete.com/blog/2017/09/all-about-strictness" class="uri">https://www.fpcomplete.com/blog/2017/09/all-about-strictness</a></li>
<li><a href="https://queue.acm.org/detail.cfm?id=2538488" class="uri">https://queue.acm.org/detail.cfm?id=2538488</a></li>
</ul>]]></summary>
</entry>
<entry>
    <title>Wait for it…a deep dive in Espresso's idling resources</title>
    <link href="https://futtetennismo.me/posts/archive/2014-04-05-wait-for-it.html" />
    <id>https://futtetennismo.me/posts/archive/2014-04-05-wait-for-it.html</id>
    <published>2014-04-05T00:00:00Z</published>
    <updated>2014-04-05T00:00:00Z</updated>
    <summary type="html"><![CDATA[<h5 id="update-a-new-better-version-of-this-post-is-available-on-the-jimdo-dev-blog.">Update: A new (better) version of this post is available on the <a href="http://dev.jimdo.com/2014/05/09/wait-for-it-a-deep-dive-into-espresso-s-idling-resources/">Jimdo Dev Blog</a>.</h5>
<p>Recently I invested a decent amount of time in making our functional tests less clunky, especially when there are async computations involved. We started using <a href="https://code.google.com/p/android-test-kit/">Espresso</a> a few days after it was released and never looked back. In this blog post I’d like to focus on how you can tell Espresso to wait for an async computation to finish before performing any actions on a <code>View</code>, and a few gotchas I learned. <!--more--> Espresso introduces the concept of <a href="https://android-test-kit.googlecode.com/git/docs/javadocs/apidocs/index.html"><code>IdlingResource</code></a>, a simple interface that</p>
<blockquote>
<p>Represents a resource of an application under test which can cause asynchronous background work to happen during test execution</p>
</blockquote>
<p>The interface defines three methods:</p>
<ul>
<li><code>getName()</code>: must return a non-null string that identifies an idling resource. Morover, as the docs state:</li>
</ul>
<blockquote>
<p>it is used for logging and <em>idempotency</em> of registration</p>
</blockquote>
<ul>
<li><code>isIdleNow()</code>: returns the current idle state of the idling resource. If it returns <code>true</code>, the <code>onTransitionToIdle()</code> method on the registered <code>ResourceCallback</code> must have been previously called.</li>
<li><code>registerIdleTransitionCallback(IdlingResource.ResourceCallback callback)</code>: normally this method is used to store a reference to the callback to notify it of a change in the idle state.</li>
</ul>
<h2 id="idling-resource-registration">Idling resource registration</h2>
<p>Registering an idling resource is really simple: just call <code>Espresso.registerIdlingResource(myIdlingResource)</code>. This call is idempotent, meaning that &gt; it can be applied multiple times without changing the result beyond the initial application.</p>
<p>This way consequent calls to <code>Espresso.registerIdlingResource(myIdlingResource)</code> for an idling resource with the same name won’t have any effect (Espresso will simply log a warning). Generally this is no big deal, but it becomes an issue if an idling resource has a dependency to the current <code>Context</code>. For example, the application under test can have a <code>WebView</code> and the tests need to wait for a page to be fully loaded. If idempotence is not taken into account and an idling resource with a reference to a <code>WebView</code> instance is registered - for example in the <code>setUp()</code> method of a test class - bad things will happen. First, subsequent tests will rely on a wrong referenced component in idling resource to be checked and will probably fail, and second the first <code>Context</code> is leaked since we’re holding a strong reference to it. The solution to that is to have an <code>ActivityLifecycleIdlingResource</code> and inject and clear the reference to a component when appropriate.</p>
<div class="sourceCode"><pre class="sourceCode java"><code class="sourceCode java"><span class="kw">abstract</span> <span class="kw">class</span> ActivityLifecycleIdlingResource&lt;T&gt; <span class="kw">implements</span> IdlingResource {
  <span class="kw">private</span> T component;

  <span class="dt">void</span> <span class="fu">inject</span>(T component) {
    <span class="kw">this</span>.<span class="fu">component</span> = component;
  }

  <span class="dt">void</span> <span class="fu">clear</span>() {
    <span class="kw">this</span>.<span class="fu">component</span> = <span class="kw">null</span>;
  }
}</code></pre></div>
<p>Another - probably less error-prone - solution would be to have an <code>Espresso.unregisterIdlingResource(myIdlingResource)</code> API, there is already a <a href="https://code.google.com/p/android-test-kit/issues/detail?id=65">feature request</a> to add it. As for registering idling resources that are needed in all tests, I ended up registering them in the <code>callApplicationOnCreate(app)</code> method of a custom <code>InstrumentationTestRunner</code>, this way I am sure the registration happens only once.</p>
<h2 id="implementing-an-idling-resource-for-a-thread-pool-executor">Implementing an idling resource for a thread pool executor</h2>
<p>There can be <a href="http://www.slideshare.net/andersgoransson/efficient-android-threading">multiple</a> <a href="http://mttkay.github.io/blog/2013/08/25/functional-reactive-programming-on-android-with-rxjava/">reasons</a> why you’d want your application to not use the built-in Android components that handle async operations, in this case you’d need to define an idling resource that checks if the executor(s) used by the application are idle. Looking at the Espresso source code, with a small refactoring to the <a href="https://code.google.com/p/android-test-kit/source/browse/espresso/lib/src/main/java/com/google/android/apps/common/testing/ui/espresso/base/AsyncTaskPoolMonitor.java"><code>AsyncTaskPoolMonitor</code></a> class (Espresso uses it to check if there is some tasks running on the <code>AsyncTask</code> thread pool executor) a general <a href="https://gist.github.com/stefanodacchille/9995163#file-threadpoolidlingresource-java"><code>ThreadPoolIdlingResource</code></a> can be implemented.</p>
<h2 id="soundtrack">Soundtrack:</h2>
<iframe width="100%" height="166" scrolling="no" frameborder="no" src="https://w.soundcloud.com/player/?url=https%3A//api.soundcloud.com/tracks/141161837&amp;color=ff5500&amp;auto_play=false&amp;hide_related=false&amp;show_artwork=true">
</iframe>]]></summary>
</entry>

</feed>
